<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Duliz's Blog"><title>面向对象程序设计 | 学习园地</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.3"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.3"></script><script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.3"></script><link rel="stylesheet" type="text/css" href="/css/kityminder.core.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/kityminder.css?v=2.0.3"><script type="text/javascript" src="/js/kity.min.js?v=2.0.3"></script><script type="text/javascript" src="/js/kityminder.core.js?v=2.0.3"></script><script type="text/javascript" src="/js/mind.js?v=2.0.3"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">面向对象程序设计</h1><a id="logo" href="/.">学习园地</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">面向对象程序设计</h1><div class="post-meta"><a href="/2019/05/12/面向对象程序设计/#comments" class="comment-count"></a><p><span class="date">May 12, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="面向对象？"><a href="#面向对象？" class="headerlink" title="面向对象？"></a>面向对象？</h3><ul>
<li>面向对象的标志: “类”   </li>
<li>通过“类”可以创建任意多个具有相同属性、方法的对象  </li>
<li>ES6之前没有“类”的概念,ES6实现了类</li>
</ul>
<h3 id="6-1理解对象"><a href="#6-1理解对象" class="headerlink" title="6.1理解对象"></a>6.1理解对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name:&quot;xxx&quot;,</span><br><span class="line">    age:26,</span><br><span class="line">    hobby:&quot;movie&quot;,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-1-1-对象属性类型"><a href="#6-1-1-对象属性类型" class="headerlink" title="6.1.1 对象属性类型"></a>6.1.1 对象属性类型</h3><p>特点：内部值，使用[[ ]]区分  </p>
<ul>
<li>数据属性</li>
<li>访问器属性  </li>
</ul>
<h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h4><ul>
<li>[[Configurable]]:能否通过delete操作符删除属性从而重新定义属性、修改属性、或者修改为访问器属性，值为true/false  </li>
<li>[[Enumerable]]:能否通过for-in循环返回属性，值为true/false    </li>
<li>[[Writable]]:能否修改属性的值，值为true/false   </li>
<li>[[Value]]:属性数据值[读取的属性]，默认值为undefined   </li>
</ul>
<p>修改属性的默认特性：Object.defineProperty()  </p>
<p>注意：<br>1.对于已经定义在obj对象上的属性，[[Configurable]]、[[Enumerable]]、[[Writable]]全部为true<br>2.若是通过Object.defineProperty()新增的属性，则[[Configurable]]、[[Enumerable]]、[[Writable]]全部默认为false<br>3.[[Configurable]]设置为false之后无法再修改回true，其他属性没有修改限制<br><!-- 实例 --></p>
<h4 id="2-访问器属性"><a href="#2-访问器属性" class="headerlink" title="2.访问器属性"></a>2.访问器属性</h4><ul>
<li>[[Configurable]]:能否通过delete操作符删除属性从而重新定义属性、修改属性、或者修改为数据属性，值为true/false  </li>
<li>[[Enumerable]]:能否通过for-in循环返回属性，值为true/false    </li>
<li>[[Get]]:读取属性时调用的函数。默认值为undefined </li>
<li>[[Set]]:写入属性时调用的函数。默认值为undefined  </li>
</ul>
<p>定义访问器属性：Object.defineProperty()   </p>
<p>注意：不一定要同时指定getter和setter，假设只设置了getter,则访问setter会报错。反之亦然  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">例：setter函数常用来设置一个值会导致其他值的改变  </span><br><span class="line">var book = &#123;</span><br><span class="line">    _year:2004,</span><br><span class="line">    edition:1</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">Object.defineProperty(book,&quot;_year&quot;,&#123;</span><br><span class="line">    get:function()&#123;</span><br><span class="line">        return this._year</span><br><span class="line">    &#125;,</span><br><span class="line">    set:function(newValue)&#123;</span><br><span class="line">        if(newValue&gt;2014)&#123;</span><br><span class="line">            this._year=newValue;</span><br><span class="line">            this.edition+=newValue-2014</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//如果该属性定义了get/set函数，则读取设置属性时必定会触发get/set函数</span><br><span class="line">book.year=2015//调用set</span><br><span class="line">console.log(book.year)//调用get方法</span><br></pre></td></tr></table></figure>
<h4 id="6-1-2-定义多个属性"><a href="#6-1-2-定义多个属性" class="headerlink" title="6.1.2 定义多个属性"></a>6.1.2 定义多个属性</h4><p>使用Object.defineProperties()   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var book=&#123;&#125;;</span><br><span class="line">Object.defineProperties(book,&#123;</span><br><span class="line">    _year:&#123;</span><br><span class="line">        writable:true,</span><br><span class="line">        value:2004</span><br><span class="line">    &#125;,</span><br><span class="line">    edition:&#123;</span><br><span class="line">        writable:true,</span><br><span class="line">        value:1</span><br><span class="line">    &#125;,</span><br><span class="line">    year:&#123;</span><br><span class="line">        get:function()&#123;</span><br><span class="line">            return this._year</span><br><span class="line">        &#125;,</span><br><span class="line">        set:function(newValue)&#123;</span><br><span class="line">            if(newValue&gt;2014)&#123;</span><br><span class="line">            this._year=newValue;</span><br><span class="line">            this.edition+=newValue-2014</span><br><span class="line">        &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="6-1-3-读取属性的特性"><a href="#6-1-3-读取属性的特性" class="headerlink" title="6.1.3 读取属性的特性"></a>6.1.3 读取属性的特性</h4><p>使用Object.getOwnPropertyDescriptor()获取数据属性和访问器属性  </p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>对象的属性类型可用于自定义符合某些规则的对象的属性，例如访问器属性中的set/get被用于VUE中的数据响应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//响应式数据绑定</span><br><span class="line">function defineReactive(obj, key, val) &#123;</span><br><span class="line">    var dep = new Dep();//每个属性都有一个dep实例来对应多个watcher</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            //添加watcher到dep中</span><br><span class="line">            if (Dep.target) dep.addSub(Dep.target)</span><br><span class="line">            return val</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function (n) &#123;</span><br><span class="line">            if (n === val) return</span><br><span class="line">            val = n;</span><br><span class="line">            // 作为发布者发出通知</span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2 创建对象"></a>6.2 创建对象</h3><h4 id="6-2-1-工厂模式"><a href="#6-2-1-工厂模式" class="headerlink" title="6.2.1 工厂模式"></a>6.2.1 工厂模式</h4><p>工厂模式?本质上就是将创建对象的步骤写在一个方法中  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var o=new Object();</span><br><span class="line">    o.name=name;</span><br><span class="line">    o.age=age;</span><br><span class="line">    o.job=job;</span><br><span class="line">    o.sayName=function()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;;</span><br><span class="line">    return o</span><br><span class="line">&#125;;</span><br><span class="line">var person1=createPerson(&quot;xxx&quot;,22,&quot;worker&quot;);</span><br><span class="line">var person2=createPerson(&quot;xxx2&quot;,52,&quot;worker&quot;)</span><br></pre></td></tr></table></figure>
<p>缺点：无法将其标记为一种特定的类型(person1与person2都是Object的实例)  </p>
<h4 id="6-2-2-构造函数模式"><a href="#6-2-2-构造函数模式" class="headerlink" title="6.2.2 构造函数模式"></a>6.2.2 构造函数模式</h4><p>像Object、Array这样的原生构造函数可以用来创建特定类型的对象，所以也可以创建自定义的构造函数的来定义自定义对象的属性和方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.age=age;</span><br><span class="line">    this.job=job;</span><br><span class="line">    this.sayName=function()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">var person1=new Person(&quot;xxx&quot;,22,&quot;worker&quot;);</span><br><span class="line">var person2=new Person(&quot;xxx2&quot;,52,&quot;worker&quot;)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>Person本身就是一个普通的函数而已，但是默认构造函数都是以首字母大写开头。要实现创建Person类的新实例，必须使用new操作符。  </p>
</li>
<li><p>使用new会经历以下4个过程<br>1、创建一个新对象<br>2、将构造函数的作用域赋给新对象（this指向新对象）<br>3、执行构造函数的代码<br>4、返回<strong>新对象</strong></p>
</li>
<li><p>标识对象类型<br>1.使用对象(Object构造函数的原型对象上)的constructor(构造函数)属性<br>2.使用instanceof(常用)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person1.constructor==Person</span><br><span class="line">person1 instanceof Person  </span><br><span class="line">person1 instanceof Object</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="1-将构造函数当作函数"><a href="#1-将构造函数当作函数" class="headerlink" title="1.将构造函数当作函数"></a>1.将构造函数当作函数</h5><ul>
<li><p>构造函数与其他函数的唯一区别就是调用方式的不同  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//接上面的例子</span><br><span class="line">//构造</span><br><span class="line">var person1=new Person(&quot;xxx&quot;,22,&quot;worker&quot;);</span><br><span class="line">person1.sayName()//xxx </span><br><span class="line">//普通</span><br><span class="line">Person(&quot;xxx2&quot;,52,&quot;worker&quot;);</span><br><span class="line">window.sayName()或者sayName()//xxx2  </span><br><span class="line">//另一对象中  </span><br><span class="line">var o=new Object();</span><br><span class="line">Person.call(o,&quot;xxx3&quot;,32,&quot;worker&quot;);</span><br><span class="line">o.sayName()//xxx3</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数的优缺点<br>1.优点：可以将自定义构造函数的实例标识为一种特定的类型<br>2.缺点： 当在构造函数中定义方法的时候，每个实例都要重新生成一个方法（对象），因为在ECMAScript中函数也是对象的一种。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.age=age;</span><br><span class="line">    this.job=job;</span><br><span class="line">    this.sayName=function()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;;</span><br><span class="line">    //等价于this.sayName=new Function(&quot;alert(this.name)&quot;)</span><br><span class="line">&#125;;</span><br><span class="line">var person1=new Person(&quot;xxx&quot;,22,&quot;worker&quot;);</span><br><span class="line">var person2=new Person(&quot;xxx2&quot;,52,&quot;worker&quot;)</span><br><span class="line">alert(person1.sayName==(person2.sayName)//false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>3.解决方案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*  </span><br><span class="line">1.将sayName指向的函数直接在函数外声明，  </span><br><span class="line">就可以避免每次实例化都要生成一次方法对象，  </span><br><span class="line">但是，这样做会在全局增加函数，那样自定义构造函数就没有封装性可言。  </span><br><span class="line">2.将方法写在原型对象中  </span><br><span class="line">*/</span><br><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.age=age;</span><br><span class="line">    this.job=job;</span><br><span class="line">    this.sayName=sayName</span><br><span class="line">&#125;;</span><br><span class="line">function sayName()&#123;</span><br><span class="line">     alert(this.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-2-3-（构造函数的）原型模式"><a href="#6-2-3-（构造函数的）原型模式" class="headerlink" title="6.2.3 （构造函数的）原型模式"></a>6.2.3 （构造函数的）原型模式</h4><ul>
<li><p><strong>函数的</strong>prototype(原型)属性<br>该属性存在于每一个<em>函数</em>之中，属性指向一个对象。此对象的作用是包含可以由特定类型的所有实例<strong>共享</strong>的属性和方法。  </p>
</li>
<li><p>用原型模式改写纯构造函数模式  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;  </span><br><span class="line">Person.prototype.name=&quot;Nicholas&quot;;</span><br><span class="line">Person.prototype.age=29;</span><br><span class="line">Person.prototype.job=&quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName=function()&#123;</span><br><span class="line">    alert(this.name)</span><br><span class="line">&#125;;</span><br><span class="line">var person1=new Person();</span><br><span class="line">var person2=new Person()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="1-理解原型对象"><a href="#1-理解原型对象" class="headerlink" title="1.理解原型对象"></a>1.理解原型对象</h5><p><img src="http://ww1.sinaimg.cn/large/005ANJbJgy1g2u13g7lkhj30ni09njsj.jpg" alt="图6-1">  </p>
<p>注意：<br>1.当<strong>创建一个新的实例</strong>，该实例内部将包含一个指针[[prototype]]，指向构造函数的prototype。这个属性没有标准的方法可以访问，但是在ff/safari/chrome中支持用_proto_表示  </p>
<p>2.默认情况下所有的原型对象都有一个constructor(构造函数)属性  指向prototype属性所在函数的指针(对象的constructor属性其实就是原型对象上的constructor)  </p>
<p><img src="http://ww1.sinaimg.cn/large/005ANJbJly1ge76are5fej30g4082dg5.jpg" alt="constructor理解图"></p>
<hr>
<p>关于原型的几个方法：<br>1.isPrototypeOf:确定原型与实例的关系<br><code>Person.prototype.isPrototypeOf(person1)//true</code> </p>
<p>2.Object.getPrototypeOf:返回实例的原型，即[[prototype]]<br><code>Object.getPrototypeOf(person1)</code>  </p>
<p>3.detele操作符：删除实例中的属性，常用于实例属性与原型属性重名的情况<br><code>delete person1.name</code>  </p>
<p>4.hasOwnProperty:检测一个属性是否存在实例中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接上面的例子</span><br><span class="line">person1.hasOwnProperty(&apos;name&apos;)//false</span><br></pre></td></tr></table></figure></p>
<h5 id="2-原型与in操作符"><a href="#2-原型与in操作符" class="headerlink" title="2.原型与in操作符"></a>2.原型与in操作符</h5><p>1).in操作符：判断对象是否能够访问给定的属性，无论这个属性是来自实例还是原型<br><code>&quot;name&quot; in person1//true</code>   </p>
<p>结合hasOwnProperty可以判断属性是否来自原型  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function hasPrototypeProperty(o,n)&#123;</span><br><span class="line">    return !o.hasOwnProperty(n) &amp;&amp; (n in o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2).for in:返回能够通过对象访问的、[[Enumerable]]为true的属性。注意：对于IE8及以上，被重复定义（用户自定义的已经存在的对象属性，默认[[Enumerable]]为true）的不可枚举的属性也可以返回  </p>
<p>3).Object.keys():获取本对象所有的<strong>可枚举[[Enumerable]]属性(不包括继承)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var keys=Object.keys(Person.prototype)//[&quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;];</span><br><span class="line">var p1=new Person()</span><br><span class="line">p1.name=2;</span><br><span class="line">p1.job=0;</span><br><span class="line">Object.defineProperty(p1,&quot;year&quot;,&#123;</span><br><span class="line">enumerable:false,vale:2019</span><br><span class="line">&#125;);</span><br><span class="line">var k2=Object.keys(p1);//[&quot;name&quot;, &quot;job&quot;]</span><br></pre></td></tr></table></figure>
<p>4).Object.getOwnPropertyNames():获取本对象所有的属性(不包括继承)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyNames(p1)//[&quot;name&quot;, &quot;job&quot;,&quot;year&quot;]</span><br></pre></td></tr></table></figure>
<h5 id="3-更简单的原型语法"><a href="#3-更简单的原型语法" class="headerlink" title="3.更简单的原型语法"></a>3.更简单的原型语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;  </span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">    name:&quot;Nicholas&quot;,</span><br><span class="line">    job:&quot;Software Engineer&quot;,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">    alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1=new Person();</span><br><span class="line">var person2=new Person();</span><br><span class="line">person1.constructor==Person//false</span><br><span class="line">person1 instanceof Person//true</span><br></pre></td></tr></table></figure>
<ul>
<li><p>即重写了原型对象，最终效果不变，但是prototype中的constructor属性就不存在了，而是会引用Object上的constructor,此时不再指向Person(这就导致实例的constructor也跟着改变)，而是指向{}的构造函数Object。这时就不能用constructor来判断对象类型，而是用instanceof  </p>
</li>
<li><p>如果要使用constructor判断，可以手动在原型对象中新增constructor属性，但是这样会导致constructor的[[Enumerable]]属性默认设置为true  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;  </span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">    //constructor:Person,//Enumerable为true</span><br><span class="line">    name:&quot;Nicholas&quot;,</span><br><span class="line">    job:&quot;Software Engineer&quot;,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">    alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">Object.defineProperty(Person.prototype,&quot;constructor&quot;,&#123;</span><br><span class="line">    enumerable:false,</span><br><span class="line">    value:Person</span><br><span class="line">&#125;)</span><br><span class="line">&#125;catch(e)&#123;</span><br><span class="line">    Person.prototype.constructor=Person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-原型的动态性"><a href="#4-原型的动态性" class="headerlink" title="4.原型的动态性"></a>4.原型的动态性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//不改写prototype的情况下</span><br><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype.sayHi=function()&#123;</span><br><span class="line">    alert(&quot;hi&quot;)</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi() //hi  </span><br><span class="line"></span><br><span class="line">//改写了prototype的情况下</span><br><span class="line">var friend = new Person();//friend在创建时就自动为实例添加了链接最初原型的[[Prototype]]指针  </span><br><span class="line"></span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">    constructor:Person,  </span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">    alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;//这个时候将会切断与friend的联系</span><br><span class="line">friend.sayName() //error</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/005ANJbJgy1g2v2r1anmmj30j70dn0uh.jpg" alt="原型的动态性">  </p>
<h5 id="5-原生对象的原型"><a href="#5-原生对象的原型" class="headerlink" title="5.原生对象的原型"></a>5.原生对象的原型</h5><h5 id="6-原型对象的问题"><a href="#6-原型对象的问题" class="headerlink" title="6.原型对象的问题"></a>6.原型对象的问题</h5><ul>
<li>缺点：所有方法、属性都在原型中共享。对于引用类型来说，假如在一个实例中改变了，其他的实例也会改变 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;  </span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">    name:&quot;Nicholas&quot;,</span><br><span class="line">    job:&quot;Software Engineer&quot;,</span><br><span class="line">    friend:[&apos;jun&apos;,&apos;sam&apos;],</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">    alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1=new Person();</span><br><span class="line">person1.friend.push(&apos;calor&apos;)</span><br><span class="line">var person2=new Person();</span><br><span class="line">console.log(person2.friend)//[&quot;jun&quot;, &quot;sam&quot;, &quot;calor&quot;]</span><br></pre></td></tr></table></figure>
<ul>
<li>缺点联想：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;button-counter&apos;, &#123;</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-2-4-组合使用构造函数模式和原型模式-默认使用"><a href="#6-2-4-组合使用构造函数模式和原型模式-默认使用" class="headerlink" title="6.2.4 组合使用构造函数模式和原型模式(默认使用)"></a>6.2.4 组合使用构造函数模式和原型模式(默认使用)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,job)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.job=job;</span><br><span class="line">    this.friend=[&apos;jun&apos;,&apos;sam&apos;]</span><br><span class="line">&#125;  </span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">    alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1=new Person();</span><br><span class="line">person1.friend.push(&apos;calor&apos;)</span><br><span class="line">var person2=new Person();</span><br><span class="line">console.log(person2.friend)//[&quot;jun&quot;, &quot;sam&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="6-2-5-动态原型模式"><a href="#6-2-5-动态原型模式" class="headerlink" title="6.2.5 动态原型模式"></a>6.2.5 动态原型模式</h4><h3 id="6-3继承"><a href="#6-3继承" class="headerlink" title="6.3继承"></a>6.3继承</h3><ul>
<li>继承的实现是依靠原型链  </li>
<li>原型链的原理<br>1.实例通过构造函数生成，因此有了[[prototype]]内部属性可以访问到构造函数的原型，因此可以继承原型上的属性与方法。<br>2.利用这个特性，我们可以重写一个构造函数的原型，使其等于另一个构造函数的<em>实例</em>，那么该原型就会有了[[prototype]]内部属性可以访问到另一个构造函数的原型，这样就形成原型链  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property=true</span><br><span class="line">&#125;;</span><br><span class="line">SuperType.prototype.getSuperValue=function()&#123;</span><br><span class="line">    return this.property</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty=false</span><br><span class="line">&#125;;</span><br><span class="line">//继承</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">//添加</span><br><span class="line">SubType.prototype.getSubValue=function()&#123;</span><br><span class="line">    return this.subproperty</span><br><span class="line">&#125;;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.getSuperValue())//true</span><br><span class="line">console.log(instance.constructor)//SuperType</span><br><span class="line">//现在引用的是SuperType.prototype.constructor</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/005ANJbJgy1g2v6m5pe7kj30is09d0tu.jpg" alt="图6-4">  </p>
<h5 id="2-确定原型和实例的关系"><a href="#2-确定原型和实例的关系" class="headerlink" title="2.确定原型和实例的关系"></a>2.确定原型和实例的关系</h5><ul>
<li>instanceof &amp;&amp; isPrototypeOf()  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperType.prototype.isPrototypeOf instance//true</span><br><span class="line">SubType.prototype.isPrototypeOf(instance)//true</span><br></pre></td></tr></table></figure>
<h5 id="3-谨慎地定义方法"><a href="#3-谨慎地定义方法" class="headerlink" title="3.谨慎地定义方法"></a>3.谨慎地定义方法</h5><h5 id="4-原型链的问题"><a href="#4-原型链的问题" class="headerlink" title="4.原型链的问题"></a>4.原型链的问题</h5><p>同样是引用类型带来的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.color=[&quot;black&quot;,&quot;blue&quot;,&quot;red&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">//继承</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">var instance2 = new SubType();</span><br><span class="line"></span><br><span class="line">instance1.color.push(&apos;pink&apos;);</span><br><span class="line">console.log(instance2.color)// [&quot;black&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;pink&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="6-3-3-组合继承（最终版本）"><a href="#6-3-3-组合继承（最终版本）" class="headerlink" title="6.3.3 组合继承（最终版本）"></a>6.3.3 组合继承（最终版本）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name=name</span><br><span class="line">    this.color=[&quot;black&quot;,&quot;blue&quot;,&quot;red&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">SuperType.prototype.sayName=function()&#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);</span><br><span class="line">    this.age=age</span><br><span class="line">&#125;;</span><br><span class="line">//继承</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.constructor=SubType;</span><br><span class="line">SubType.prototype.sayAge=function()&#123;</span><br><span class="line">    return this.age</span><br><span class="line">&#125;;</span><br><span class="line">var instance1 = new SubType(&quot;c1&quot;,20);</span><br><span class="line">instance1.color.push(&quot;pink&quot;);</span><br><span class="line">console.log(instance1.sayName());//c1</span><br><span class="line">console.log(instance1.sayAge());//20</span><br><span class="line">var instance2 = new SubType(&quot;c2&quot;,63);</span><br><span class="line">console.log(instance2.sayName());//c2</span><br><span class="line">console.log(instance2.sayAge());//63</span><br><span class="line">console.log(instance2.color)// [&quot;black&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;pink&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h3><h4 id="检测数组-Array-prototype-isArray"><a href="#检测数组-Array-prototype-isArray" class="headerlink" title="检测数组:Array.prototype.isArray()"></a>检测数组:Array.prototype.isArray()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;</span><br><span class="line">    arr1:[]</span><br><span class="line">&#125;</span><br><span class="line">Array.isArray(obj.arr1);//true</span><br><span class="line">Array.isArray(obj.arr2);//Array.isArray(undefined);false</span><br></pre></td></tr></table></figure>
<ul>
<li>instanceof 和 isArray<br>当检测Array实例时, Array.isArray 优于 instanceof,因为Array.isArray能检测iframes。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">document.body.appendChild(iframe);</span><br><span class="line">//获取iframe对象下的Array方法</span><br><span class="line">xArray = window.frames[window.frames.length-1].Array;</span><br><span class="line">var arr = new xArray(1,2,3); // [1,2,3]</span><br><span class="line"></span><br><span class="line">// Correctly checking for Array</span><br><span class="line">Array.isArray(arr);  // true</span><br><span class="line">// Considered harmful, because doesn&apos;t work though iframes</span><br><span class="line">arr instanceof Array; // false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="原型与object与null"><a href="#原型与object与null" class="headerlink" title="原型与object与null"></a>原型与object与null</h4><p><img src="http://ww1.sinaimg.cn/large/005ANJbJly1ge76ok0uzxj30ge0elt9d.jpg" alt="原型与object与null"><br>1、Person.prototype本身也是个对象，那么它是构造函数就是Objcet,_proto_自然就指向Object.prototype<br>2、null的定义是表示一个空对象指针。所以 Object.prototype._proto_ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<h3 id="ES6的类"><a href="#ES6的类" class="headerlink" title="ES6的类"></a>ES6的类</h3><h4 id="ES6的类是通过class关键字定义的"><a href="#ES6的类是通过class关键字定义的" class="headerlink" title="ES6的类是通过class关键字定义的"></a>ES6的类是通过class关键字定义的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Point(x, y) &#123;</span><br><span class="line">  this.x = x;</span><br><span class="line">  this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = function () &#123;</span><br><span class="line">  return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p = new Point(1, 2);</span><br><span class="line">Object.keys(Point.prototype)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;//定义在原型上</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;//不可加逗号</span><br><span class="line"></span><br><span class="line">  toString() &#123;//定义在prototype</span><br><span class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var p = new Point(1, 2);</span><br><span class="line">Object.keys(Point.prototype);//[]</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  constructor() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。而构造函数可以</li>
</ul>
<h4 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const MyClass = class&#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>class后面也可以跟着类名，但是此类名只能在类中使用，不可以在外部不可调用  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const MyClass = class Me &#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    return Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>采用 Class 表达式，可以写出立即执行的 Class。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let person = new class &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(&apos;张三&apos;);</span><br></pre></td></tr></table></figure>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">javaScript深入之从原型到原型链</a>  </p>
</div><div class="post-copyright"><blockquote><p>原文作者: Duliz</p><p>原文链接: <a href="https://duliz.github.io/2019/05/12/面向对象程序设计/">https://duliz.github.io/2019/05/12/面向对象程序设计/</a></p><p>版权声明: 转载请注明出处</p></blockquote></div><div class="tags"><a href="/tags/JS高设笔记/">JS高设笔记</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/05/23/模块化编程/" class="pre">模块化编程</a><a href="/2019/05/12/用markdown生成脑图/" class="next">用markdown生成脑图</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象？"><span class="toc-text">面向对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1理解对象"><span class="toc-text">6.1理解对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-对象属性类型"><span class="toc-text">6.1.1 对象属性类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-数据类型"><span class="toc-text">1.数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-访问器属性"><span class="toc-text">2.访问器属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-定义多个属性"><span class="toc-text">6.1.2 定义多个属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-读取属性的特性"><span class="toc-text">6.1.3 读取属性的特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-创建对象"><span class="toc-text">6.2 创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-工厂模式"><span class="toc-text">6.2.1 工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-构造函数模式"><span class="toc-text">6.2.2 构造函数模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-将构造函数当作函数"><span class="toc-text">1.将构造函数当作函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-（构造函数的）原型模式"><span class="toc-text">6.2.3 （构造函数的）原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-理解原型对象"><span class="toc-text">1.理解原型对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-原型与in操作符"><span class="toc-text">2.原型与in操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-更简单的原型语法"><span class="toc-text">3.更简单的原型语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-原型的动态性"><span class="toc-text">4.原型的动态性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-原生对象的原型"><span class="toc-text">5.原生对象的原型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-原型对象的问题"><span class="toc-text">6.原型对象的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-组合使用构造函数模式和原型模式-默认使用"><span class="toc-text">6.2.4 组合使用构造函数模式和原型模式(默认使用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-5-动态原型模式"><span class="toc-text">6.2.5 动态原型模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3继承"><span class="toc-text">6.3继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-确定原型和实例的关系"><span class="toc-text">2.确定原型和实例的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-谨慎地定义方法"><span class="toc-text">3.谨慎地定义方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-原型链的问题"><span class="toc-text">4.原型链的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-组合继承（最终版本）"><span class="toc-text">6.3.3 组合继承（最终版本）</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#番外"><span class="toc-text">番外</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#检测数组-Array-prototype-isArray"><span class="toc-text">检测数组:Array.prototype.isArray()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型与object与null"><span class="toc-text">原型与object与null</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6的类"><span class="toc-text">ES6的类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6的类是通过class关键字定义的"><span class="toc-text">ES6的类是通过class关键字定义的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class-表达式"><span class="toc-text">Class 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考链接"><span class="toc-text">参考链接</span></a></li></ol></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/事情循环机制/">事件循环机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/代码运行过程/">JS代码运行过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/模块化编程/">模块化编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/12/面向对象程序设计/">面向对象程序设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/12/用markdown生成脑图/">用markdown生成脑图</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/08/第一篇hexo-blog-使用hexo与github搭建个人博客/">第一篇 hello Hexo && 使用Hexo与Github搭建个人博客</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/JS高设笔记/" style="font-size: 15px;">JS高设笔记</a> <a href="/tags/笔记/" style="font-size: 15px;">笔记</a> <a href="/tags/脑图/" style="font-size: 15px;">脑图</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Duliz.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>