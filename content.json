[{"title":"模块化编程","date":"2019-05-23T09:10:59.000Z","path":"2019/05/23/模块化编程/","text":"CommonJS规范与node.js的模块系统123456789101112//a.jsvar num=1function numPlus(plus)&#123; return num+plus&#125;;module.exports = &#123; num: num, numPlus: numPlus&#125;//index.jsvar a_module = require(&apos;./a&apos;);a_module.numPlus(2); commonJS用同步的方式加载模块,在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。对于浏览器，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间。因此，浏览器端的模块，只能采用”异步加载”。这就是AMD规范诞生的背景。 AMD规范和require.js 12345678910111213141516171819202122232425262728293031323334353637//index.html&lt;script data-main=&quot;scripts/main&quot; src=&quot;lib/require.js&quot;&gt;&lt;/script&gt; //入口文件：main.js require.config(&#123; baseUrl: &apos;&apos;, paths: &#123; jquery: [&apos;https://cdn.bootcss.com/jquery/3.3.1/jquery&apos;,&apos;lib/jquery&apos;], hello: &apos;scripts/hello&apos; &#125;&#125;); require([&apos;jquery&apos;, &apos;hello&apos;],function ($, hello) &#123; $(&quot;#btn&quot;).click(function()&#123; hello.showMessage(&quot;hangge.com&quot;); &#125;);&#125;);//hello.jsdefine([&apos;jquery&apos;],function($)&#123; var moduleName = &quot;hello module&quot;; var moduleVersion = &quot;1.0&quot;; var showMessage = function(name)&#123; if(undefined === name)&#123; return; &#125;else&#123; $(&apos;#messageBox&apos;).html(&apos;欢迎访问 &apos; + name); &#125; &#125;; //暴露(返回)本模块API return &#123; &quot;moduleName&quot;:moduleName, &quot;version&quot;: moduleVersion, &quot;showMessage&quot;: showMessage &#125;&#125;); AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 但是，由于AMD推崇的是依赖前置、提前执行，即定义在define中的模块，即时未在回调中使用，但是只要定义了就一定会提前加载。1234567define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) &#123; // 等于在最前面声明并初始化了要用到的所有模块 if (false) &#123; // 即便没用到某个模块 b，但 b 还是提前执行了 b.foo() &#125; &#125;); CMD规范和sea.js12345678910111213141516171819202122//main.jsdefine(function(require, exports, module) &#123; // 通过 require 按需引入依赖 var $ = require(&apos;jquery&apos;); var Spinning = require(&apos;./spinning&apos;); // 通过 exports 对外提供接口 exports.doSomething = ... // 或者通过 module.exports 提供整个接口 module.exports = ...&#125;);// index.htmlseajs.config(&#123; base: &quot;../sea-modules/&quot;,//加载文件的基准路径 alias: &#123; &quot;jquery&quot;: &quot;jquery/jquery/1.10.1/jquery.js&quot; &#125;&#125;)seajs.use([&apos;main.js&apos;], function(a)&#123;&#125;); ES6 Module1.export模式 export的变量名与import接收的变量名必须是一致的 可以有多个export import需要加上{} 12345678910111213141516//profile.jsvar firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;var year = 1958;var age = 18export &#123;firstName, lastName, year&#125;;export &#123;age&#125;//// main.jsimport &#123;firstName, lastName, year&#125; from &apos;./profile.js&apos;; import &#123;age&#125; from &apos;./profile.js&apos;; //.js后缀可以省略 //import命令具有提升效果，会提升到整个模块的头部，首先执行//import的值可以直接使用function setName(element) &#123; element.textContent = firstName + &apos; &apos; + lastName;&#125; 2.export default 模式:为模块指定默认输出。 export default的变量名与import接收的变量名必须是一致的 只能有一个export default,因为输出的变量名已经设置为default import不需要加上{}，并且变量名可以自己取 本质：export default命令的本质是将后面的值，赋给default变量。 123456789101112var firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;var year = 1958;var age = 18export default &#123; firstName, lastName, year&#125;;export &#123;year&#125;import myName from &apos;./profile&apos;;import &#123;year&#125; from &apos;./profile&apos;; 3.ES6 Module与CommonJs/AMD/CMD的区别12345678910111213141516171819201.CommonJsvar num=1module.exports = &#123; num: num,&#125;var a_module = require(&apos;./a&apos;);//需要赋值给a_modulea_module.num;上面代码的实质是整体加载a模块（即加载a的exports的所有方法），生成一个对象（a_module），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。2.Module var firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;var year = 1958;export &#123; firstName, lastName, year&#125;;import &#123;firstName, lastName, year&#125; from &apos;./profile.js&apos;; //可以直接使用firstName, lastName, year上面代码的实质是从profile模块加载 3 个变量，其他变量不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新 参考文章Module的语法前端模块化：CommonJS,AMD,CMD,ES6","tags":[{"name":"笔记","slug":"笔记","permalink":"https://duliz.github.io/tags/笔记/"}]},{"title":"面向对象程序设计","date":"2019-05-12T07:22:31.000Z","path":"2019/05/12/面向对象程序设计/","text":"面向对象？ 面向对象的标志: “类” 通过“类”可以创建任意多个具有相同属性、方法的对象 ES6之前没有“类”的概念,ES6实现了类 6.1理解对象12345678var person = &#123; name:&quot;xxx&quot;, age:26, hobby:&quot;movie&quot;, sayName:function()&#123; alert(this.name) &#125;&#125; 6.1.1 对象属性类型特点：内部值，使用[[ ]]区分 数据属性 访问器属性 1.数据类型 [[Configurable]]:能否通过delete操作符删除属性从而重新定义属性、修改属性、或者修改为访问器属性，值为true/false [[Enumerable]]:能否通过for-in循环返回属性，值为true/false [[Writable]]:能否修改属性的值，值为true/false [[Value]]:属性数据值[读取的属性]，默认值为undefined 修改属性的默认特性：Object.defineProperty() 注意：1.对于已经定义在obj对象上的属性，[[Configurable]]、[[Enumerable]]、[[Writable]]全部为true2.若是通过Object.defineProperty()新增的属性，则[[Configurable]]、[[Enumerable]]、[[Writable]]全部默认为false3.[[Configurable]]设置为false之后无法再修改回true，其他属性没有修改限制 2.访问器属性 [[Configurable]]:能否通过delete操作符删除属性从而重新定义属性、修改属性、或者修改为数据属性，值为true/false [[Enumerable]]:能否通过for-in循环返回属性，值为true/false [[Get]]:读取属性时调用的函数。默认值为undefined [[Set]]:写入属性时调用的函数。默认值为undefined 定义访问器属性：Object.defineProperty() 注意：不一定要同时指定getter和setter，假设只设置了getter,则访问setter会报错。反之亦然 1234567891011121314151617181920例：setter函数常用来设置一个值会导致其他值的改变 var book = &#123; _year:2004, edition:1&#125;; Object.defineProperty(book,&quot;_year&quot;,&#123; get:function()&#123; return this._year &#125;, set:function(newValue)&#123; if(newValue&gt;2014)&#123; this._year=newValue; this.edition+=newValue-2014 &#125; &#125;&#125;);//如果该属性定义了get/set函数，则读取设置属性时必定会触发get/set函数book.year=2015//调用setconsole.log(book.year)//调用get方法 6.1.2 定义多个属性使用Object.defineProperties() 12345678910111213141516171819202122var book=&#123;&#125;;Object.defineProperties(book,&#123; _year:&#123; writable:true, value:2004 &#125;, edition:&#123; writable:true, value:1 &#125;, year:&#123; get:function()&#123; return this._year &#125;, set:function(newValue)&#123; if(newValue&gt;2014)&#123; this._year=newValue; this.edition+=newValue-2014 &#125; &#125; &#125;&#125;) 6.1.3 读取属性的特性使用Object.getOwnPropertyDescriptor()获取数据属性和访问器属性 使用场景对象的属性类型可用于自定义符合某些规则的对象的属性，例如访问器属性中的set/get被用于VUE中的数据响应1234567891011121314151617//响应式数据绑定function defineReactive(obj, key, val) &#123; var dep = new Dep();//每个属性都有一个dep实例来对应多个watcher Object.defineProperty(obj, key, &#123; get: function () &#123; //添加watcher到dep中 if (Dep.target) dep.addSub(Dep.target) return val &#125;, set: function (n) &#123; if (n === val) return val = n; // 作为发布者发出通知 dep.notify(); &#125; &#125;)&#125; 6.2 创建对象6.2.1 工厂模式工厂模式?本质上就是将创建对象的步骤写在一个方法中 123456789101112function createPerson(name,age,job)&#123; var o=new Object(); o.name=name; o.age=age; o.job=job; o.sayName=function()&#123; alert(this.name) &#125;; return o&#125;;var person1=createPerson(&quot;xxx&quot;,22,&quot;worker&quot;);var person2=createPerson(&quot;xxx2&quot;,52,&quot;worker&quot;) 缺点：无法将其标记为一种特定的类型(person1与person2都是Object的实例) 6.2.2 构造函数模式像Object、Array这样的原生构造函数可以用来创建特定类型的对象，所以也可以创建自定义的构造函数的来定义自定义对象的属性和方法12345678910function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function()&#123; alert(this.name) &#125;;&#125;;var person1=new Person(&quot;xxx&quot;,22,&quot;worker&quot;);var person2=new Person(&quot;xxx2&quot;,52,&quot;worker&quot;) Person本身就是一个普通的函数而已，但是默认构造函数都是以首字母大写开头。要实现创建Person类的新实例，必须使用new操作符。 使用new会经历以下4个过程1、创建一个新对象2、将构造函数的作用域赋给新对象（this指向新对象）3、执行构造函数的代码4、返回新对象 标识对象类型1.使用对象(Object构造函数的原型对象上)的constructor(构造函数)属性2.使用instanceof(常用) 123person1.constructor==Personperson1 instanceof Person person1 instanceof Object 1.将构造函数当作函数 构造函数与其他函数的唯一区别就是调用方式的不同 1234567891011//接上面的例子//构造var person1=new Person(&quot;xxx&quot;,22,&quot;worker&quot;);person1.sayName()//xxx //普通Person(&quot;xxx2&quot;,52,&quot;worker&quot;);window.sayName()或者sayName()//xxx2 //另一对象中 var o=new Object();Person.call(o,&quot;xxx3&quot;,32,&quot;worker&quot;);o.sayName()//xxx3 构造函数的优缺点1.优点：可以将自定义构造函数的实例标识为一种特定的类型2.缺点： 当在构造函数中定义方法的时候，每个实例都要重新生成一个方法（对象），因为在ECMAScript中函数也是对象的一种。 123456789101112function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function()&#123; alert(this.name) &#125;; //等价于this.sayName=new Function(&quot;alert(this.name)&quot;)&#125;;var person1=new Person(&quot;xxx&quot;,22,&quot;worker&quot;);var person2=new Person(&quot;xxx2&quot;,52,&quot;worker&quot;)alert(person1.sayName==(person2.sayName)//false 3.解决方案123456789101112131415/* 1.将sayName指向的函数直接在函数外声明， 就可以避免每次实例化都要生成一次方法对象， 但是，这样做会在全局增加函数，那样自定义构造函数就没有封装性可言。 2.将方法写在原型对象中 */function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=sayName&#125;;function sayName()&#123; alert(this.name)&#125; 6.2.3 （构造函数的）原型模式 函数的prototype(原型)属性该属性存在于每一个函数之中，属性指向一个对象。此对象的作用是包含可以由特定类型的所有实例共享的属性和方法。 用原型模式改写纯构造函数模式 123456789function Person()&#123;&#125; Person.prototype.name=&quot;Nicholas&quot;;Person.prototype.age=29;Person.prototype.job=&quot;Software Engineer&quot;;Person.prototype.sayName=function()&#123; alert(this.name)&#125;;var person1=new Person();var person2=new Person() 1.理解原型对象 注意：1.当创建一个新的实例，该实例内部将包含一个指针[[prototype]]，指向构造函数的prototype。这个属性没有标准的方法可以访问，但是在ff/safari/chrome中支持用_proto_表示 2.默认情况下所有的原型对象都有一个constructor(构造函数)属性 指向prototype属性所在函数的指针(对象的constructor属性其实就是原型对象上的constructor) 关于原型的几个方法：1.isPrototypeOf:确定原型与实例的关系Person.prototype.isPrototypeOf(person1)//true 2.Object.getPrototypeOf:返回实例的原型，即[[prototype]]Object.getPrototypeOf(person1) 3.detele操作符：删除实例中的属性，常用于实例属性与原型属性重名的情况delete person1.name 4.hasOwnProperty:检测一个属性是否存在实例中12接上面的例子person1.hasOwnProperty(&apos;name&apos;)//false 2.原型与in操作符1).in操作符：判断对象是否能够访问给定的属性，无论这个属性是来自实例还是原型&quot;name&quot; in person1//true 结合hasOwnProperty可以判断属性是否来自原型 123function hasPrototypeProperty(o,n)&#123; return !o.hasOwnProperty(n) &amp;&amp; (n in o)&#125; 2).for in:返回能够通过对象访问的、[[Enumerable]]为true的属性。注意：对于IE8及以上，被重复定义（用户自定义的已经存在的对象属性，默认[[Enumerable]]为true）的不可枚举的属性也可以返回 3).Object.keys():获取本对象所有的可枚举[[Enumerable]]属性(不包括继承) 12345678var keys=Object.keys(Person.prototype)//[&quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;];var p1=new Person()p1.name=2;p1.job=0;Object.defineProperty(p1,&quot;year&quot;,&#123;enumerable:false,vale:2019&#125;);var k2=Object.keys(p1);//[&quot;name&quot;, &quot;job&quot;] 4).Object.getOwnPropertyNames():获取本对象所有的属性(不包括继承) 1Object.getOwnPropertyNames(p1)//[&quot;name&quot;, &quot;job&quot;,&quot;year&quot;] 3.更简单的原型语法123456789101112function Person()&#123;&#125; Person.prototype=&#123; name:&quot;Nicholas&quot;, job:&quot;Software Engineer&quot;, sayName:function()&#123; alert(this.name) &#125;&#125;;var person1=new Person();var person2=new Person();person1.constructor==Person//falseperson1 instanceof Person//true 即重写了原型对象，最终效果不变，但是prototype中的constructor属性就不存在了，而是会引用Object上的constructor,此时不再指向Person(这就导致实例的constructor也跟着改变)，而是指向{}的构造函数Object。这时就不能用constructor来判断对象类型，而是用instanceof 如果要使用constructor判断，可以手动在原型对象中新增constructor属性，但是这样会导致constructor的[[Enumerable]]属性默认设置为true 123456789101112131415161718function Person()&#123;&#125; Person.prototype=&#123; //constructor:Person,//Enumerable为true name:&quot;Nicholas&quot;, job:&quot;Software Engineer&quot;, sayName:function()&#123; alert(this.name) &#125;&#125;;try&#123;Object.defineProperty(Person.prototype,&quot;constructor&quot;,&#123; enumerable:false, value:Person&#125;)&#125;catch(e)&#123; Person.prototype.constructor=Person&#125; 4.原型的动态性1234567891011121314151617//不改写prototype的情况下var friend = new Person();Person.prototype.sayHi=function()&#123; alert(&quot;hi&quot;)&#125;;friend.sayHi() //hi //改写了prototype的情况下var friend = new Person();//friend在创建时就自动为实例添加了链接最初原型的[[Prototype]]指针 Person.prototype=&#123; constructor:Person, sayName:function()&#123; alert(this.name) &#125;&#125;;//这个时候将会切断与friend的联系friend.sayName() //error 5.原生对象的原型6.原型对象的问题 缺点：所有方法、属性都在原型中共享。对于引用类型来说，假如在一个实例中改变了，其他的实例也会改变 12345678910111213function Person()&#123;&#125; Person.prototype=&#123; name:&quot;Nicholas&quot;, job:&quot;Software Engineer&quot;, friend:[&apos;jun&apos;,&apos;sam&apos;], sayName:function()&#123; alert(this.name) &#125;&#125;;var person1=new Person();person1.friend.push(&apos;calor&apos;)var person2=new Person();console.log(person2.friend)//[&quot;jun&quot;, &quot;sam&quot;, &quot;calor&quot;] 缺点联想：1234567Vue.component(&apos;button-counter&apos;, &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;,&#125;) 6.2.4 组合使用构造函数模式和原型模式(默认使用)1234567891011121314function Person(name,job)&#123; this.name=name; this.job=job; this.friend=[&apos;jun&apos;,&apos;sam&apos;]&#125; Person.prototype=&#123; sayName:function()&#123; alert(this.name) &#125;&#125;;var person1=new Person();person1.friend.push(&apos;calor&apos;)var person2=new Person();console.log(person2.friend)//[&quot;jun&quot;, &quot;sam&quot;] 6.2.5 动态原型模式6.3继承 继承的实现是依靠原型链 原型链的原理1.实例通过构造函数生成，因此有了[[prototype]]内部属性可以访问到构造函数的原型，因此可以继承原型上的属性与方法。2.利用这个特性，我们可以重写一个构造函数的原型，使其等于另一个构造函数的实例，那么该原型就会有了[[prototype]]内部属性可以访问到另一个构造函数的原型，这样就形成原型链 12345678910111213141516171819function SuperType()&#123; this.property=true&#125;;SuperType.prototype.getSuperValue=function()&#123; return this.property&#125;;function SubType()&#123; this.subproperty=false&#125;;//继承SubType.prototype = new SuperType();//添加SubType.prototype.getSubValue=function()&#123; return this.subproperty&#125;;var instance = new SubType();alert(instance.getSuperValue())//trueconsole.log(instance.constructor)//SuperType//现在引用的是SuperType.prototype.constructor 2.确定原型和实例的关系 instanceof &amp;&amp; isPrototypeOf() 12SuperType.prototype.isPrototypeOf instance//trueSubType.prototype.isPrototypeOf(instance)//true 3.谨慎地定义方法4.原型链的问题同样是引用类型带来的问题 123456789101112131415function SuperType()&#123; this.color=[&quot;black&quot;,&quot;blue&quot;,&quot;red&quot;]&#125;;function SubType()&#123; &#125;;//继承SubType.prototype = new SuperType();var instance1 = new SubType();var instance2 = new SubType();instance1.color.push(&apos;pink&apos;);console.log(instance2.color)// [&quot;black&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;pink&quot;] 6.3.3 组合继承（最终版本）12345678910111213141516171819202122232425function SuperType(name)&#123; this.name=name this.color=[&quot;black&quot;,&quot;blue&quot;,&quot;red&quot;]&#125;;SuperType.prototype.sayName=function()&#123; return this.name&#125;;function SubType(name,age)&#123; SuperType.call(this,name); this.age=age&#125;;//继承SubType.prototype = new SuperType();SubType.prototype.constructor=SubType;SubType.prototype.sayAge=function()&#123; return this.age&#125;;var instance1 = new SubType(&quot;c1&quot;,20);instance1.color.push(&quot;pink&quot;);console.log(instance1.sayName());//c1console.log(instance1.sayAge());//20var instance2 = new SubType(&quot;c2&quot;,63);console.log(instance2.sayName());//c2console.log(instance2.sayAge());//63console.log(instance2.color)// [&quot;black&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;pink&quot;] 番外检测数组:Array.prototype.isArray()12345var obj=&#123; arr1:[]&#125;Array.isArray(obj.arr1);//trueArray.isArray(obj.arr2);//Array.isArray(undefined);false instanceof 和 isArray当检测Array实例时, Array.isArray 优于 instanceof,因为Array.isArray能检测iframes。12345678910var iframe = document.createElement(&apos;iframe&apos;);document.body.appendChild(iframe);//获取iframe对象下的Array方法xArray = window.frames[window.frames.length-1].Array;var arr = new xArray(1,2,3); // [1,2,3]// Correctly checking for ArrayArray.isArray(arr); // true// Considered harmful, because doesn&apos;t work though iframesarr instanceof Array; // false 原型与object与null1、Person.prototype本身也是个对象，那么它是构造函数就是Objcet,_proto_自然就指向Object.prototype2、null的定义是表示一个空对象指针。所以 Object.prototype._proto_ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。所以查找属性的时候查到 Object.prototype 就可以停止查找了。 ES6的类ES6的类是通过class关键字定义的1234567891011function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;&#125;;var p = new Point(1, 2);Object.keys(Point.prototype) 123456789101112131415161718class Point &#123; constructor(x, y) &#123;//定义在原型上 this.x = x; this.y = y; &#125;//不可加逗号 toString() &#123;//定义在prototype return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125;;var p = new Point(1, 2);Object.keys(Point.prototype);//[]// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;&#125;; 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。而构造函数可以 Class 表达式123const MyClass = class&#123; &#125;; class后面也可以跟着类名，但是此类名只能在类中使用，不可以在外部不可调用 12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 采用 Class 表达式，可以写出立即执行的 Class。 123456789let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;(&apos;张三&apos;); 参考链接javaScript深入之从原型到原型链","tags":[{"name":"JS高设笔记","slug":"JS高设笔记","permalink":"https://duliz.github.io/tags/JS高设笔记/"}]},{"title":"用markdown生成脑图","date":"2019-05-12T07:22:01.000Z","path":"2019/05/12/用markdown生成脑图/","text":"说明 生成脑图工具：百度kityminder kityminder分为kityminder-core和kityminder-editor。 kityminder-core是 KityMinder 的核心实现部分，包括： 脑图数据的可视化展示（Json 格式）简单的编辑功能（节点创建、编辑、删除） kityminder-core 又依赖于Kity,kity 是一个基于 SVG 的矢量图形库 实现过程1.将js文件放置于themes/BlueLake/source/js文件中kity.min.jskityminder.core.js 2.将css文件转化为styl文件放置于themes/BlueLake/source/css文件中kityminder.core.styl 3.新建mind.js(themes/BlueLake/source/js)初始化脑图1234567891011121314151617setTimeout(function() &#123; var mindmap=document.querySelector(&quot;.mindmap&quot;) if (mindmap)&#123; var minder = new kityminder.Minder(&#123; renderTo: &apos;.mindmap&apos; &#125;); var markdownText = mindmap.innerText.trim(); mindmap.querySelectorAll(&quot;p&quot;).forEach(function(element,index) &#123; element.style.display = &apos;none&apos;; &#125;); minder.importData(&apos;markdown&apos;, markdownText); minder.disable(); minder.execCommand(&apos;hand&apos;);&#125;&#125;,100) 4.全局引入,在themes\\BlueLake\\layout\\base.jade中引入js与css1234link(rel=&apos;stylesheet&apos;, type=&apos;text/css&apos;, href=url_for(theme.css) + &apos;/kityminder.core.css&apos; + &apos;?v=&apos; + theme.version) script(type=&apos;text/javascript&apos;, src=url_for(theme.js) + &apos;/kity.min.js&apos; + &apos;?v=&apos; + theme.version)script(type=&apos;text/javascript&apos;, src=url_for(theme.js) + &apos;/kityminder.core.js&apos; + &apos;?v=&apos; + theme.version)script(type=&apos;text/javascript&apos;, src=url_for(theme.js) + &apos;/mind.js&apos; + &apos;?v=&apos; + theme.version) 5.在需要使用的页面中使用123456789&#123;% pullquote mindmap %&#125;#主题##一级分支###二级分支##一级分支##一级分支###二级分支####三级分支&#123;% endpullquote %&#125; #主题 ##一级分支 ###二级分支 ##一级分支 ##一级分支 ###二级分支 ####三级分支 注意事项1.当前版本仅支持本页面生成一个脑图（mind.js中的mindmap）2.全局引入js、css且执行延迟函数，考虑将其作为一个自定义模板 参考资料Hexo 渲染思维导图Hexo中使用markdown来绘制脑图（mind map）","tags":[{"name":"脑图","slug":"脑图","permalink":"https://duliz.github.io/tags/脑图/"}]},{"title":"第一篇 hello Hexo && 使用Hexo与Github搭建个人博客","date":"2019-04-08T14:27:50.000Z","path":"2019/04/08/第一篇hexo-blog-使用hexo与github搭建个人博客/","text":"初识Hexo介绍Hexo与Github搭建个人博客 初识hexoHexo是一款基于Node.js的可用于搭建静态博客框架 Hexo与Github搭建个人博客搭建所需要的工具 Github的一个新建库 Node/git客户端/cmd vsCode(支持markdown语法的编辑器) Hexo/Hexo主题：BlueLake 新建一个Github库注意：库名一定要使用.github.io作为后缀 Git安装成功后的初始化1.将Git与GitHub帐号绑定桌面右键–&gt;Git Bash Here输入 git config --global user.name &quot;&quot; git config --global user.email &quot;&quot; 2.填写个人信息，生成ssh密钥ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;然后直接三个回车即可，默认不需要设置密码找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 直接打开GitHub_Settings_keys，新建一个新的SSH Keys title可以随意填写，Key填写刚刚复制的id_rsa.pub内容测试是否设置成功：ssh git@github.com 在vsCode中使用Git Bash终端在vsCode(v1.33+)也可以直接开启Git Bash。方法：先找到Git Bash安装文件地址在vsCode中：设置–&gt;用户设置–&gt;终端–&gt;setting.json保存之后快捷键Ctrl + `打开终端控制台即可切换Bash 安装Hexo1.新建文件夹(myBlog)用来存放整个“网站”2.进入myBlog，在Node/Git Bash中都可以安装npm install -g hexo-cli安装成功后查看版本hexo -v3.在myBlog中新建main文件夹用于初始化一个网站hexo init main注意：init后面也可以不加文件夹，则默认在当前文件夹下创建，当要注意文件必须为空cd main进入mainnpm install成功安装完的文件结构如下 _config.ymlpackage.jsonscaffoldsthemessource _drafts_posts 部署到github1.安装hexo-deployer-gitnpm install hexo-deployer-git --save2.修改站点_config.yml配置 安装自定义主题1.在main文件夹下安装 123git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake npm install hexo-renderer-jade@0.3.0 --save npm install hexo-renderer-stylus --save 2.修改站点_config.yml配置文件，修改主题为BlueLaketheme: BlueLake 为主题新添iconfont在BlueLake主题中已经存在默认的iconfont 这些图片的命名规则由”fa-“ + 主题配置项_config.yml的中以下label决定 具体代码实现是位于themes/BlueLake/layout/page.jade 添加步骤：在不改变内部实现代码的前提下1.下载新的iconfont2.解压之后将svg、ttf、woff、woff2、eot文件改名并复制到themes/BlueLake/layout/source/iconfont文件夹下 3.在themes/BlueLake/layout/source/css/style.styl中新增一条@font-face规则 然后再添加 12.fa-QQ:before content: &quot;\\e64c&quot; 新建一篇博客hexo n &quot;博客名字&quot;生成后的博客位于themes/BlueLake/layout/source/_posts/生成的文件后缀名为md，该文件使用markdown编写(markdown语法记录在Markdown与图床) 新建一篇草稿草稿:位于themes/BlueLake/layout/source/drafts,drafts中的页面不会发布在线上hexo new draft 文章名 预览草稿hexo S --draft 将草稿部署为线上文章123hexo P 文章名 hexo g hexo d 原理:将文章从 source/_drafts 移动到 source/_posts 全局部署到线上12hexo g hexo d 可简写为1hexo g -d 新建关于我页面hexo new page &#39;about&#39;BlueLake会自动与about按钮关联 为BlueLake添加搜索功能npm install hexo-generator-json-content@2.2.0 --save然后在站点_config.yml配置添加 1234567891011121314151617181920# theme blueLake search## Docs: https://chaoo.oschina.io/2016/12/29/BlueLake%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE.htmljsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true hexo命令 命令 简写 内容 参数 hexo server hexo s 开启服务器 -p:重设端口/-l:启动日记记录，使用覆盖记录格式 hexo generate hexo g 生成静态文件 -d:文件生成后立即部署网站/-w:监视文件变动 hexo deploy hexo d 部署网站 -g:部署之前预先生成静态文件 hexo clean 无 清除缓存文件 (db.json) 和已生成的静态文件 (public) 无 用npm管理命令123456// package.json &quot;scripts&quot;: &#123; &quot;draft&quot;: &quot;hexo S --draft&quot;, &quot;dev&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s --debug&quot;, &quot;deploy&quot;: &quot;hexo g -d&quot; &#125;, 博客置顶在BlueLake中已经存在置顶的标签themes/BlueLake/layout/index.jade但是置顶功能需要自己实现1234567891011121314var posts = locals.posts;//将原来的posts注释后加上 posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排&#125;); 然后在需要置顶的博客的Front-matter中加入top123456---title: 个人简历date: 2019-04-12 00:08:33tags:top: 2--- 修改要重新启动服务 资料参考链接GitHub+Hexo 搭建个人网站详细教程hexo-theme-BlueLake最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析hexo中文文档Hexo文章置顶的方法Hexo 文章保存为草稿","tags":[]}]