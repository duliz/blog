[{"title":"模块化编程","date":"2019-05-23T09:10:59.000Z","path":"2019/05/23/模块化编程/","text":"CommonJS规范与node.js的模块系统123456789101112//a.jsvar num=1function numPlus(plus)&#123; return num+plus&#125;;module.exports = &#123; num: num, numPlus: numPlus&#125;//index.jsvar a_module = require(&apos;./a&apos;);a_module.numPlus(2); commonJS用同步的方式加载模块,在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。对于浏览器，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间。因此，浏览器端的模块，只能采用”异步加载”。这就是AMD规范诞生的背景。 AMD规范和require.js 12345678910111213141516171819202122232425262728293031323334353637//index.html&lt;script data-main=&quot;scripts/main&quot; src=&quot;lib/require.js&quot;&gt;&lt;/script&gt; //入口文件：main.js require.config(&#123; baseUrl: &apos;&apos;, paths: &#123; jquery: [&apos;https://cdn.bootcss.com/jquery/3.3.1/jquery&apos;,&apos;lib/jquery&apos;], hello: &apos;scripts/hello&apos; &#125;&#125;); require([&apos;jquery&apos;, &apos;hello&apos;],function ($, hello) &#123; $(&quot;#btn&quot;).click(function()&#123; hello.showMessage(&quot;hangge.com&quot;); &#125;);&#125;);//hello.jsdefine([&apos;jquery&apos;],function($)&#123; var moduleName = &quot;hello module&quot;; var moduleVersion = &quot;1.0&quot;; var showMessage = function(name)&#123; if(undefined === name)&#123; return; &#125;else&#123; $(&apos;#messageBox&apos;).html(&apos;欢迎访问 &apos; + name); &#125; &#125;; //暴露(返回)本模块API return &#123; &quot;moduleName&quot;:moduleName, &quot;version&quot;: moduleVersion, &quot;showMessage&quot;: showMessage &#125;&#125;); AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 但是，由于AMD推崇的是依赖前置、提前执行，即定义在define中的模块，即时未在回调中使用，但是只要定义了就一定会提前加载。1234567define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) &#123; // 等于在最前面声明并初始化了要用到的所有模块 if (false) &#123; // 即便没用到某个模块 b，但 b 还是提前执行了 b.foo() &#125; &#125;); CMD规范和sea.js12345678910111213141516171819202122//main.jsdefine(function(require, exports, module) &#123; // 通过 require 按需引入依赖 var $ = require(&apos;jquery&apos;); var Spinning = require(&apos;./spinning&apos;); // 通过 exports 对外提供接口 exports.doSomething = ... // 或者通过 module.exports 提供整个接口 module.exports = ...&#125;);// index.htmlseajs.config(&#123; base: &quot;../sea-modules/&quot;,//加载文件的基准路径 alias: &#123; &quot;jquery&quot;: &quot;jquery/jquery/1.10.1/jquery.js&quot; &#125;&#125;)seajs.use([&apos;main.js&apos;], function(a)&#123;&#125;); ES6 Module1.export模式 export的变量名与import接收的变量名必须是一致的 可以有多个export import需要加上{} 12345678910111213141516//profile.jsvar firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;var year = 1958;var age = 18export &#123;firstName, lastName, year&#125;;export &#123;age&#125;//// main.jsimport &#123;firstName, lastName, year&#125; from &apos;./profile.js&apos;; import &#123;age&#125; from &apos;./profile.js&apos;; //.js后缀可以省略 //import命令具有提升效果，会提升到整个模块的头部，首先执行//import的值可以直接使用function setName(element) &#123; element.textContent = firstName + &apos; &apos; + lastName;&#125; 2.export default 模式:为模块指定默认输出。 export default的变量名与import接收的变量名必须是一致的 只能有一个export default,因为输出的变量名已经设置为default import不需要加上{}，并且变量名可以自己取 本质：export default命令的本质是将后面的值，赋给default变量。 123456789101112var firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;var year = 1958;var age = 18export default &#123; firstName, lastName, year&#125;;export &#123;year&#125;import myName from &apos;./profile&apos;;import &#123;year&#125; from &apos;./profile&apos;; 3.ES6 Module与CommonJs/AMD/CMD的区别12345678910111213141516171819201.CommonJsvar num=1module.exports = &#123; num: num,&#125;var a_module = require(&apos;./a&apos;);//需要赋值给a_modulea_module.num;上面代码的实质是整体加载a模块（即加载a的exports的所有方法），生成一个对象（a_module），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。2.Module var firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;var year = 1958;export &#123; firstName, lastName, year&#125;;import &#123;firstName, lastName, year&#125; from &apos;./profile.js&apos;; //可以直接使用firstName, lastName, year上面代码的实质是从profile模块加载 3 个变量，其他变量不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新 参考文章Module的语法前端模块化：CommonJS,AMD,CMD,ES6","tags":[{"name":"笔记","slug":"笔记","permalink":"https://duliz.github.io/tags/笔记/"}]},{"title":"执行环境及作用域","date":"2019-05-18T07:48:38.000Z","path":"2019/05/18/执行环境及作用域/","text":"执行环境(执行上下文) 概念：执行环境定义了变量和函数有权访问的其他数据，决定了他们各自的行为。 分类： 环境 对象 内容 何时销毁 全局执行环境 window对象 函数声明、变量 退出程序后销毁 函数执行环境 活动对象 作用域链、this、arguments、当前执行代码所在环境的变量对象 执行完毕后销毁 变量对象 概念：保存环境中定义的所有变量和函数 作用域链 概念：当代码在一个环境中执行的时候，会最终形成变量对象的一个作用域链 作用：保证对执行环境有权访问的所有变量和函数的有序访问 本质：一个指向变量对象的指针列表 函数的作用域链 全局执行环境 包含的外部环境 ↑ 活动对象(当前执行代码所在环境的变量对象+arguments对象) ↑ 一个无嵌套函数执行过程的分析123456789function compare(v1,v2)&#123; if(v1&lt;v2)&#123; return -1 &#125;else if(v1&gt;v2)&#123; return 1 &#125;else&#123; return 0 &#125;&#125; 作用域对象[[Scopes]]概念：当compare函数被创建的时候,comparec的标识符（identifier）就被加到了当前的作用域对象中（在这里就是全局对象），并且这个标识符所引用的是一个函数对象（function object）。函数对象中所包含的是函数的源代码以及其他的属性。其中一个就是内部属性[[scope]]。[[scope]]所指向的就是当前的作用域对象。也就是指的就是函数的标识符被创建的时候，我们所能够直接访问的那个作用域对象（在这里就是全局对象）。 “直接访问”的意思就是，在当前作用域链中，该作用域对象处于最底层，没有子作用域对象。 1.compare创建时，先创建一个预先包含全局变量对象的作用域对象，这个作用域被保存在[[Scopes]]属性中。2.compare调用时会创建一个执行环境，然后通过复制Scopes对象构建起执行环境的作用域链。然后又创建compare执行环境的活动对象【compare scope】，并将其推入到作用域链的前端。3.compare执行完毕时，如果没有被其他对象引用，则compare的作用域链对象【compare scope】将被销毁 函数作用域与闭包 闭包概念闭包是指有权访问另一个函数作用域的变量的函数 创建方式在一个函数内部创建另一个函数 一个嵌套函数(闭包)执行过程的分析闭包产生的问题1—占用内存当一个函数返回后，如果没有其他对象保存对其的引用，那么它就可能被垃圾回收器回收。但是如果我们在函数当中定义嵌套的函数并且返回，这个嵌套的函数的[[scope]]就会引用外围函数（Outer function）的当前作用域对象。如果我们将这个嵌套函数返回，并被另外一个地方的标识符所引用的话，那么这个嵌套函数及其[[scope]]所引用的作用域对象就不会被垃圾回收所销毁。 12345678910111213141516function createComparisonFunction(propertyName)&#123; return function(obj1,obj2)&#123; var v1=obj1[propertyName]; var v2=obj2[propertyName]; if(v1&lt;v2)&#123; return -1 &#125;else if(v1&gt;v2)&#123; return 1 &#125;else&#123; return 0 &#125; &#125;&#125;;var compare = createComparisonFunction(&apos;name&apos;);var result = compare(&#123;name:&apos;zzz&apos;&#125;,&#123;name:&apos;ccc&apos;&#125;);compare = null;//解除对匿名函数的引用 例子1: 123456789101112var add=function(x)&#123; var sum=0; var temp=function(x)&#123; sum = sum + x; return temp; &#125;; temp.toString = function()&#123; return sum; &#125;; return temp&#125;;console.log(add(100)(2)(5))//7 add(100)返回的是temp函数，函数里面返回temp 闭包产生的问题2—变量对象的值 原因：闭包只能取得包含函数中任何变量的最后一个值 12345678910111213141516171819202122例子1.function createFunction()&#123; var result = new Array(); for(var i=0;i&lt;10;i++)&#123; result[i] = function()&#123; return i //所有都为10 &#125; &#125;; return result;&#125;例子2.var i,a;for(i =0;i&lt;10;i++)&#123; a=document.createElement(&apos;a&apos;); a.innerHTML=i+&apos;&lt;br&gt;&apos;; a.addEventListener(&apos;click&apos;,function(e)&#123; e.preventDefault(); alert(i)//80 &#125;); document.body.appendChild(a)&#125;i=80 匿名函数中的i都是引用createFunction的活动对象中的同一个i,当createFunction执行返回的时候，此时i已经变为10。 修改方法—块级作用域 1234567891011function createFunction()&#123; var result = new Array(); for(var i=0;i&lt;10;i++)&#123; result[i] = function(num)&#123;//关键点：块级作用域，函数参数按值传递 return function()&#123; return num &#125; &#125;(i) &#125;; return result;&#125;; 闭包使用场景 块级作用域（立即执行的闭包函数）变量提升 由于js本身并没有块级作用域的概念，因此就会出现一下的情况 123456789function outputNumber(count)&#123; for(var i=0;i&lt;count;i++)&#123; console.log(i) &#125;; var i;//变量提升时被忽略 console.log(i)//5,在for循环外面依旧可以访问到i的值 &#125;; outputNumber(5) 块级作用域的基本写法 (function(i){})(i) //其实和普通调用函数是一样的，但是匿名函数没有name属性或var block = function(i){}(i) 模块模式（模块化基础）1234567891011121314var modules=function()&#123; var privateValue = 1; function privateFunction()&#123; return privateValue &#125;; return &#123; privateVersion:1, privateFunction:function()&#123; privateValue++; return privateFunction() &#125; &#125;&#125;() 例:Jquery声明$函数123456789101112131415161718192021222324// 使用函数自执行的方式创建模块(function(window, undefined) &#123; // 声明jQuery构造函数 var jQuery = function(name) &#123; // 主动在构造函数中，返回一个jQuery实例 return new jQuery.fn.init(name); &#125; // 添加原型方法 jQuery.prototype = jQuery.fn = &#123; constructor: jQuery, init:function() &#123; ... &#125;, css: function() &#123; ... &#125; &#125; jQuery.fn.init.prototype = jQuery.fn; // 将jQuery改名为$，并将引用保存在window上，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了 window.jQuery = window.$ = jQuery; &#125;)(window);// 在使用时，我们直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候在自己new了$(&apos;#div1&apos;); 模块模式Plus宽放大模式 如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块。 123456var module1 = ( function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod; &#125;)(window.module1 || &#123;&#125;);//避免module1在未声明赋值时使用 参考资料执行上下文Javascript模块化编程（一）：模块的写法JavaScript闭包的底层运行机制","tags":[{"name":"JS高设笔记","slug":"JS高设笔记","permalink":"https://duliz.github.io/tags/JS高设笔记/"}]},{"title":"面向对象程序设计","date":"2019-05-12T07:22:31.000Z","path":"2019/05/12/面向对象程序设计/","text":"面向对象？ 面向对象的标志: “类” 通过“类”可以创建任意多个具有相同属性、方法的对象 ESMAScript没有“类”的概念 6.1理解对象12345678var person = &#123; name:&quot;xxx&quot;, age:26, hobby:&quot;movie&quot;, sayName:function()&#123; alert(this.name) &#125;&#125; 6.1.1 对象属性类型特点：内部值，使用[[ ]]区分 数据属性 访问器属性 1.数据类型 [[Configurable]]:能否通过delete操作符删除属性从而重新定义属性、修改属性、或者修改为访问器属性，值为true/false [[Enumerable]]:能否通过for-in循环返回属性，值为true/false [[Writable]]:能否修改属性的值，值为true/false [[Value]]:属性数据值[读取的属性]，默认值为undefined 修改属性的默认特性：Object.defineProperty() 注意：1.对于已经定义在obj对象上的属性，[[Configurable]]、[[Enumerable]]、[[Writable]]全部为true2.若是通过Object.defineProperty()新增的属性，则[[Configurable]]、[[Enumerable]]、[[Writable]]全部默认为false3.[[Configurable]]设置为false之后无法再修改回true，其他属性没有修改限制 2.访问器属性 [[Configurable]]:能否通过delete操作符删除属性从而重新定义属性、修改属性、或者修改为数据属性，值为true/false [[Enumerable]]:能否通过for-in循环返回属性，值为true/false [[Get]]:读取属性时调用的函数。默认值为undefined [[Set]]:写入属性时调用的函数。默认值为undefined 定义访问器属性：Object.defineProperty() 注意：不一定要同时指定getter和setter，假设只设置了getter,则访问setter会报错。反之亦然 1234567891011121314151617181920例：setter函数常用来设置一个值会导致其他值的改变 var book = &#123; _year:2004, edition:1&#125;; Object.defineProperty(book,&quot;_year&quot;,&#123; get:function()&#123; return this._year &#125;, set:function(newValue)&#123; if(newValue&gt;2014)&#123; this._year=newValue; this.edition+=newValue-2014 &#125; &#125;&#125;);//如果该属性定义了get/set函数，则读取设置属性时必定会触发get/set函数book.year=2015//调用setconsole.log(book.year)//调用get方法 6.1.2 定义多个属性使用Object.defineProperties() 12345678910111213141516171819202122var book=&#123;&#125;;Object.defineProperties(book,&#123; _year:&#123; writable:true, value:2004 &#125;, edition:&#123; writable:true, value:1 &#125;, year:&#123; get:function()&#123; return this._year &#125;, set:function(newValue)&#123; if(newValue&gt;2014)&#123; this._year=newValue; this.edition+=newValue-2014 &#125; &#125; &#125;&#125;) 6.1.3 读取属性的特性使用Object.getOwnPropertyDescriptor()获取数据属性和访问器属性 使用场景对象的属性类型可用于自定义符合某些规则的对象的属性，例如访问器属性中的set/get被用于VUE中的数据响应1234567891011121314151617//响应式数据绑定function defineReactive(obj, key, val) &#123; var dep = new Dep();//每个属性都有一个dep实例来对应多个watcher Object.defineProperty(obj, key, &#123; get: function () &#123; //添加watcher到dep中 if (Dep.target) dep.addSub(Dep.target) return val &#125;, set: function (n) &#123; if (n === val) return val = n; // 作为发布者发出通知 dep.notify(); &#125; &#125;)&#125; 6.2 创建对象6.2.1 工厂模式工厂模式?本质上就是将创建对象的步骤写在一个方法中 123456789101112function createPerson(name,age,job)&#123; var o=new Object(); o.name=name; o.age=age; o.job=job; o.sayName=function()&#123; alert(this.name) &#125;; return o&#125;;var person1=createPerson(&quot;xxx&quot;,22,&quot;worker&quot;);var person2=createPerson(&quot;xxx2&quot;,52,&quot;worker&quot;) 缺点：无法将其标记为一种特定的类型(person1与person2都是Object的实例) 6.2.2 构造函数模式像Object、Array这样的原生构造函数可以用来创建特定类型的对象，所以也可以创建自定义的构造函数的来定义自定义对象的属性和方法12345678910function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function()&#123; alert(this.name) &#125;;&#125;;var person1=new Person(&quot;xxx&quot;,22,&quot;worker&quot;);var person2=new Person(&quot;xxx2&quot;,52,&quot;worker&quot;) Person本身就是一个普通的函数而已，但是默认构造函数都是以首字母大写开头。要实现创建Person类的新实例，必须使用new操作符。 使用new会经历以下4个过程 创建一个新对象将构造函数的作用域赋给新对象（this指向新对象） 执行构造函数的代码返回新对象 标识对象类型1.使用对象(Object构造函数的原型对象上)的constructor(构造函数)属性2.使用instanceof(常用) 123person1.constructor==Personperson1 instanceof Person person1 instanceof Object 1.将构造函数当作函数 构造函数与其他函数的唯一区别就是调用方式的不同 1234567891011//接上面的例子//构造var person1=new Person(&quot;xxx&quot;,22,&quot;worker&quot;);person1.sayName()//xxx //普通Person(&quot;xxx2&quot;,52,&quot;worker&quot;);window.sayName()或者sayName()//xxx2 //另一对象中 var o=new Object();Person.call(o,&quot;xxx3&quot;,32,&quot;worker&quot;);o.sayName()//xxx3 构造函数的优缺点1.优点：可以将自定义构造函数的实例标识为一种特定的类型2.缺点： 当在构造函数中定义方法的时候，每个实例都要重新生成一个方法（对象），因为在ECMAScript中函数也是对象的一种。 123456789101112function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function()&#123; alert(this.name) &#125;; //等价于this.sayName=new Function(&quot;alert(this.name)&quot;)&#125;;var person1=new Person(&quot;xxx&quot;,22,&quot;worker&quot;);var person2=new Person(&quot;xxx2&quot;,52,&quot;worker&quot;)alert(person1.sayName==(person2.sayName)//false 3.解决方案12345678910111213141516/* 1.将sayName指向的函数直接在函数外声明， 就可以避免每次实例化都要生成一次方法对象， 但是，这样做会在全局增加函数，那样自定义构造函数就没有封装性可言。 2.将方法写在原型对象中 */function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=sayName //等价于this.sayName=new Function(&quot;alert(this.name)&quot;)&#125;;function sayName()&#123; alert(this.name)&#125; 6.2.3 （构造函数的）原型模式 函数的prototype(原型)属性该属性存在于每一个函数之中，属性指向一个对象。此对象的作用是包含可以由特定类型的所有实例共享的属性和方法。 用原型模式改写纯构造函数模式 123456789function Person()&#123;&#125; Person.prototype.name=&quot;Nicholas&quot;;Person.prototype.age=29;Person.prototype.job=&quot;Software Engineer&quot;;Person.prototype.sayName=function()&#123; alert(this.name)&#125;;var person1=new Person();var person2=new Person() 1.理解原型对象 注意：1.当创建一个新的实例，该实例内部将包含一个指针[[prototype]]，指向构造函数的prototype。这个属性没有标准的方法可以访问，但是在ff/safari/chrome中支持用_proto_表示 2.默认情况下所有的原型对象都有一个constructor(构造函数)属性 指向prototype属性所在函数的指针(对象的constructor属性其实就是原型对象上的constructor) 关于原型的几个方法：1.isPrototypeOf:确定原型与实例的关系Person.prototype.isPrototypeOf(person1)//true 2.Object.getPrototypeOf:返回实例的原型，即[[prototype]]Object.getPrototypeOf(person1) 3.detele操作符：删除实例中的属性，常用于实例属性与原型属性重名的情况delete person1.name 4.hasOwnProperty:检测一个属性是否存在实例中12接上面的例子person1.hasOwnProperty(&apos;name&apos;)//false 2.原型与in操作符1).in操作符：判断对象是否能够访问给定的属性，无论这个属性是来自实例还是原型&quot;name&quot; in person1//true 结合hasOwnProperty可以判断属性是否来自原型 123function hasPrototypeProperty(o,n)&#123; return !o.hasOwnProperty(n) &amp;&amp; (n in o)&#125; 2).for in:返回能够通过对象访问的、[[Enumerable]]为true的属性。注意：对于IE8及以上，被重复定义（用户自定义的已经存在的对象属性，默认[[Enumerable]]为true）的不可枚举的属性也可以返回 3).Object.keys():获取本对象所有的可枚举[[Enumerable]]属性(不包括继承)12345678var keys=Object.keys(Person.prototype)//[&quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;];var p1=new Person()p1.name=2;p1.job=0;Object.defineProperty(p1,&quot;year&quot;,&#123;enumerable:false,vale:2019&#125;);var k2=Object.keys(p1);//[&quot;name&quot;, &quot;job&quot;] 4).Object.getOwnPropertyNames():获取本对象所有的属性(不包括继承) 1Object.getOwnPropertyNames(p1)//[&quot;name&quot;, &quot;job&quot;,&quot;year&quot;] 3.更简单的原型语法123456789101112function Person()&#123;&#125; Person.prototype=&#123; name:&quot;Nicholas&quot;, job:&quot;Software Engineer&quot;, sayName:function()&#123; alert(this.name) &#125;&#125;;var person1=new Person();var person2=new Person();person1.constructor==Person//falseperson1 instanceof Person//true 即重写了原型对象，最终效果不变，但是prototype中的constructor属性就不存在了，而是会引用Object上的constructor,此时不再指向Person(这就导致实例的constructor也跟着改变)，而是指向{}的构造函数Object。这时就不能用constructor来判断对象类型，而是用instanceof 如果要使用constructor判断，可以手动在原型对象中新增constructor属性，但是这样会导致constructor的[[Enumerable]]属性默认设置为true 123456789101112131415161718function Person()&#123;&#125; Person.prototype=&#123; //constructor:Person,//Enumerable为true name:&quot;Nicholas&quot;, job:&quot;Software Engineer&quot;, sayName:function()&#123; alert(this.name) &#125;&#125;;try&#123;Object.defineProperty(Person.prototype,&quot;constructor&quot;,&#123; enumerable:false, value:Person&#125;)&#125;catch(e)&#123; Person.prototype.constructor=Person&#125; 4.原型的动态性1234567891011121314151617//不改写prototype的情况下var friend = new Person();Person.prototype.sayHi=function()&#123; alert(&quot;hi&quot;)&#125;;friend.sayHi() //hi //改写了prototype的情况下var friend = new Person();//friend在创建时就自动为实例添加了链接最初原型的[[Prototype]]指针 Person.prototype=&#123; constructor:Person, sayName:function()&#123; alert(this.name) &#125;&#125;;//这个时候将会切断与friend的联系friend.sayName() //error 5.原生对象的原型6.原型对象的问题 缺点：所有方法、属性都在原型中共享。对于引用类型来说，假如在一个实例中改变了，其他的实例也会改变 12345678910111213function Person()&#123;&#125; Person.prototype=&#123; name:&quot;Nicholas&quot;, job:&quot;Software Engineer&quot;, friend:[&apos;jun&apos;,&apos;sam&apos;], sayName:function()&#123; alert(this.name) &#125;&#125;;var person1=new Person();person1.friend.push(&apos;calor&apos;)var person2=new Person();console.log(person2.friend)//[&quot;jun&quot;, &quot;sam&quot;, &quot;calor&quot;] 缺点联想：1234567Vue.component(&apos;button-counter&apos;, &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;,&#125;) 6.2.4 组合使用构造函数模式和原型模式(默认使用)1234567891011121314function Person(name,job)&#123; this.name=name; this.job=job; this.friend=[&apos;jun&apos;,&apos;sam&apos;]&#125; Person.prototype=&#123; sayName:function()&#123; alert(this.name) &#125;&#125;;var person1=new Person();person1.friend.push(&apos;calor&apos;)var person2=new Person();console.log(person2.friend)//[&quot;jun&quot;, &quot;sam&quot;] 6.2.5 动态原型模式6.3继承 继承的实现是依靠原型链 原型链的原理1.实例通过构造函数生成，因此有了[[prototype]]内部属性可以访问到构造函数的原型，因此可以继承原型上的属性与方法。2.利用这个特性，我们可以重写一个构造函数的原型，使其等于另一个构造函数的实例，那么该原型就会有了[[prototype]]内部属性可以访问到另一个构造函数的原型，这样就形成原型链 12345678910111213141516171819function SuperType()&#123; this.property=true&#125;;SuperType.prototype.getSuperValue=function()&#123; return this.property&#125;;function SubType()&#123; this.subproperty=false&#125;;//继承SubType.prototype = new SuperType();//添加SubType.prototype.getSubValue=function()&#123; return this.subproperty&#125;;var instance = new SubType();alert(instance.getSuperValue())//trueconsole.log(instance.constructor)//SuperType//现在引用的是SuperType.prototype.constructor 2.确定原型和实例的关系 instanceof &amp;&amp; isPrototypeOf() 12SuperType.prototype.isPrototypeOf instance//trueSubType.prototype.isPrototypeOf(instance)//true 3.谨慎地定义方法4.原型链的问题同样是引用类型带来的问题 123456789101112131415function SuperType()&#123; this.color=[&quot;black&quot;,&quot;blue&quot;,&quot;red&quot;]&#125;;function SubType()&#123; &#125;;//继承SubType.prototype = new SuperType();var instance1 = new SubType();var instance2 = new SubType();instance1.color.push(&apos;pink&apos;);console.log(instance2.color)// [&quot;black&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;pink&quot;] 6.3.3 组合继承（最终版本）12345678910111213141516171819202122232425function SuperType(name)&#123; this.name=name this.color=[&quot;black&quot;,&quot;blue&quot;,&quot;red&quot;]&#125;;SuperType.prototype.sayName=function()&#123; return this.name&#125;;function SubType(name,age)&#123; SuperType.call(this,name); this.age=age&#125;;//继承SubType.prototype = new SuperType();SubType.prototype.constructor=SubType;SubType.prototype.sayAge=function()&#123; return this.age&#125;;var instance1 = new SubType(&quot;c1&quot;,20);instance1.color.push(&quot;pink&quot;);console.log(instance1.sayName());//c1console.log(instance1.sayAge());//20var instance2 = new SubType(&quot;c2&quot;,63);console.log(instance2.sayName());//c2console.log(instance2.sayAge());//63console.log(instance2.color)// [&quot;black&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;pink&quot;] 番外 检测数组:Array.prototype.isArray() 12345var obj=&#123; arr1:[]&#125;Array.isArray(obj.arr1);//trueArray.isArray(obj.arr2);//Array.isArray(undefined);false instanceof 和 isArray当检测Array实例时, Array.isArray 优于 instanceof,因为Array.isArray能检测iframes。 12345678910var iframe = document.createElement(&apos;iframe&apos;);document.body.appendChild(iframe);//获取iframe对象下的Array方法xArray = window.frames[window.frames.length-1].Array;var arr = new xArray(1,2,3); // [1,2,3]// Correctly checking for ArrayArray.isArray(arr); // true// Considered harmful, because doesn&apos;t work though iframesarr instanceof Array; // false","tags":[{"name":"JS高设笔记","slug":"JS高设笔记","permalink":"https://duliz.github.io/tags/JS高设笔记/"}]},{"title":"用markdown生成脑图","date":"2019-05-12T07:22:01.000Z","path":"2019/05/12/用markdown生成脑图/","text":"说明 生成脑图工具：百度kityminder kityminder分为kityminder-core和kityminder-editor。 kityminder-core是 KityMinder 的核心实现部分，包括： 脑图数据的可视化展示（Json 格式）简单的编辑功能（节点创建、编辑、删除） kityminder-core 又依赖于Kity,kity 是一个基于 SVG 的矢量图形库 实现过程1.将js文件放置于themes/BlueLake/source/js文件中kity.min.jskityminder.core.js 2.将css文件转化为styl文件放置于themes/BlueLake/source/css文件中kityminder.core.styl 3.新建mind.js(themes/BlueLake/source/js)初始化脑图1234567891011121314151617setTimeout(function() &#123; var mindmap=document.querySelector(&quot;.mindmap&quot;) if (mindmap)&#123; var minder = new kityminder.Minder(&#123; renderTo: &apos;.mindmap&apos; &#125;); var markdownText = mindmap.innerText.trim(); mindmap.querySelectorAll(&quot;p&quot;).forEach(function(element,index) &#123; element.style.display = &apos;none&apos;; &#125;); minder.importData(&apos;markdown&apos;, markdownText); minder.disable(); minder.execCommand(&apos;hand&apos;);&#125;&#125;,100) 4.全局引入,在themes\\BlueLake\\layout\\base.jade中引入js与css1234link(rel=&apos;stylesheet&apos;, type=&apos;text/css&apos;, href=url_for(theme.css) + &apos;/kityminder.core.css&apos; + &apos;?v=&apos; + theme.version) script(type=&apos;text/javascript&apos;, src=url_for(theme.js) + &apos;/kity.min.js&apos; + &apos;?v=&apos; + theme.version)script(type=&apos;text/javascript&apos;, src=url_for(theme.js) + &apos;/kityminder.core.js&apos; + &apos;?v=&apos; + theme.version)script(type=&apos;text/javascript&apos;, src=url_for(theme.js) + &apos;/mind.js&apos; + &apos;?v=&apos; + theme.version) 5.在需要使用的页面中使用123456789&#123;% pullquote mindmap %&#125;#主题##一级分支###二级分支##一级分支##一级分支###二级分支####三级分支&#123;% endpullquote %&#125; #主题 ##一级分支 ###二级分支 ##一级分支 ##一级分支 ###二级分支 ####三级分支 注意事项1.当前版本仅支持本页面生成一个脑图（mind.js中的mindmap）2.全局引入js、css且执行延迟函数，考虑将其作为一个自定义模板 参考资料Hexo 渲染思维导图Hexo中使用markdown来绘制脑图（mind map）","tags":[{"name":"脑图","slug":"脑图","permalink":"https://duliz.github.io/tags/脑图/"}]},{"title":"第一篇 hello Hexo && 使用Hexo与Github搭建个人博客","date":"2019-04-08T14:27:50.000Z","path":"2019/04/08/第一篇hexo-blog-使用hexo与github搭建个人博客/","text":"初识Hexo介绍Hexo与Github搭建个人博客 初识hexoHexo是一款基于Node.js的可用于搭建静态博客框架 Hexo与Github搭建个人博客搭建所需要的工具 Github的一个新建库 Node/git客户端/cmd vsCode(支持markdown语法的编辑器) Hexo/Hexo主题：BlueLake 新建一个Github库注意：库名一定要使用.github.io作为后缀 Git安装成功后的初始化1.将Git与GitHub帐号绑定桌面右键–&gt;Git Bash Here输入 git config --global user.name &quot;&quot; git config --global user.email &quot;&quot; 2.填写个人信息，生成ssh密钥ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;然后直接三个回车即可，默认不需要设置密码找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 直接打开GitHub_Settings_keys，新建一个新的SSH Keys title可以随意填写，Key填写刚刚复制的id_rsa.pub内容测试是否设置成功：ssh git@github.com 在vsCode中使用Git Bash终端在vsCode(v1.33+)也可以直接开启Git Bash。方法：先找到Git Bash安装文件地址在vsCode中：设置–&gt;用户设置–&gt;终端–&gt;setting.json保存之后快捷键Ctrl + `打开终端控制台即可切换Bash 安装Hexo1.新建文件夹(myBlog)用来存放整个“网站”2.进入myBlog，在Node/Git Bash中都可以安装npm install -g hexo-cli安装成功后查看版本hexo -v3.在myBlog中新建main文件夹用于初始化一个网站hexo init main注意：init后面也可以不加文件夹，则默认在当前文件夹下创建，当要注意文件必须为空cd main进入mainnpm install成功安装完的文件结构如下 _config.ymlpackage.jsonscaffoldsthemessource _drafts_posts 部署到github1.安装hexo-deployer-gitnpm install hexo-deployer-git --save2.修改站点_config.yml配置3.生成静态文件，部署到Github中hexo g -d或 12hexo ghexo d 安装自定义主题1.在main文件夹下安装 123git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake npm install hexo-renderer-jade@0.3.0 --save npm install hexo-renderer-stylus --save 2.修改站点_config.yml配置文件，修改主题为BlueLaketheme: BlueLake 为主题新添iconfont在BlueLake主题中已经存在默认的iconfont 这些图片的命名规则由”fa-“ + 主题配置项_config.yml的中以下label决定 具体代码实现是位于themes/BlueLake/layout/page.jade 添加步骤：在不改变内部实现代码的前提下1.下载新的iconfont2.解压之后将svg、ttf、woff、woff2、eot文件改名并复制到themes/BlueLake/layout/source/iconfont文件夹下 3.在themes/BlueLake/layout/source/css/style.styl中新增一条@font-face规则 然后再添加 12.fa-QQ:before content: &quot;\\e64c&quot; 新建一篇博客hexo n &quot;博客名字&quot;生成后的博客位于themes/BlueLake/layout/source/_posts/生成的文件后缀名为md，该文件使用markdown编写(markdown语法记录在Markdown与图床) 新建一篇草稿草稿:位于themes/BlueLake/layout/source/drafts,drafts中的页面不会发布在线上hexo new draft 文章名 预览草稿hexo S --draft 将草稿发布为正式文章123hexo P 文章名 hexo g hexo d 原理:将文章从 source/_drafts 移动到 source/_posts 新建关于我页面hexo new page &#39;about&#39;BlueLake会自动与about按钮关联 为BlueLake添加搜索功能npm install hexo-generator-json-content@2.2.0 --save然后在站点_config.yml配置添加 1234567891011121314151617181920# theme blueLake search## Docs: https://chaoo.oschina.io/2016/12/29/BlueLake%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE.htmljsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 本地预览123hexo cleanhexo ghexo s --debug 博客置顶在BlueLake中已经存在置顶的标签themes/BlueLake/layout/index.jade但是置顶功能需要自己实现1234567891011121314var posts = locals.posts;//将原来的posts注释后加上 posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排&#125;); 然后在需要置顶的博客的Front-matter中加入top123456---title: 个人简历date: 2019-04-12 00:08:33tags:top: 2--- 修改要重新启动服务 资料参考链接GitHub+Hexo 搭建个人网站详细教程hexo-theme-BlueLake最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析hexo中文文档Hexo文章置顶的方法Hexo 文章保存为草稿","tags":[]}]