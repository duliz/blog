[{"title":"面向对象程序设计","date":"2019-05-12T07:22:31.000Z","path":"2019/05/12/面向对象程序设计/","text":"面向对象？ 面向对象的标志: “类” 通过“类”可以创建任意多个具有相同属性、方法的对象 ESMAScript没有“类”的概念 6.1理解对象12345678var person = &#123; name:&quot;xxx&quot;, age:26, hobby:&quot;movie&quot;, sayName:function()&#123; alert(this.name) &#125;&#125; 6.1.1 对象属性类型特点：内部值，使用[[ ]]区分 数据属性 访问器属性 1.数据类型 [[Configurable]]:能否通过delete操作符删除属性从而重新定义属性、修改属性、或者修改为访问器属性，值为true/false [[Enumerable]]:能否通过for-in循环返回属性，值为true/false [[Writable]]:能否修改属性的值，值为true/false [[Value]]:属性数据值[读取的属性]，默认值为undefined 修改属性的默认特性：Object.defineProperty() 注意：1.对于已经定义在obj对象上的属性，[[Configurable]]、[[Enumerable]]、[[Writable]]全部为true2.若是通过Object.defineProperty()新增的属性，则[[Configurable]]、[[Enumerable]]、[[Writable]]全部默认为false3.[[Configurable]]设置为false之后无法再修改回true，其他属性没有修改限制 2.访问器属性 [[Configurable]]:能否通过delete操作符删除属性从而重新定义属性、修改属性、或者修改为数据属性，值为true/false [[Enumerable]]:能否通过for-in循环返回属性，值为true/false [[Get]]:读取属性时调用的函数。默认值为undefined [[Set]]:写入属性时调用的函数。默认值为undefined 定义访问器属性：Object.defineProperty() 注意：不一定要同时指定getter和setter，假设只设置了getter,则访问setter会报错。反之亦然 1234567891011121314151617181920例：setter函数常用来设置一个值会导致其他值的改变 var book = &#123; _year:2004, edition:1&#125;; Object.defineProperty(book,&quot;_year&quot;,&#123; get:function()&#123; return this._year &#125;, set:function(newValue)&#123; if(newValue&gt;2014)&#123; this._year=newValue; this.edition+=newValue-2014 &#125; &#125;&#125;);//如果该属性定义了get/set函数，则读取设置属性时必定会触发get/set函数book.year=2015//调用setconsole.log(book.year)//调用get方法 6.1.2 定义多个属性使用Object.defineProperties() 12345678910111213141516171819202122var book=&#123;&#125;;Object.defineProperties(book,&#123; _year:&#123; writable:true, value:2004 &#125;, edition:&#123; writable:true, value:1 &#125;, year:&#123; get:function()&#123; return this._year &#125;, set:function(newValue)&#123; if(newValue&gt;2014)&#123; this._year=newValue; this.edition+=newValue-2014 &#125; &#125; &#125;&#125;) 6.1.3 读取属性的特性使用Object.getOwnPropertyDescriptor()获取数据属性和访问器属性 使用场景对象的属性类型可用于自定义符合某些规则的对象的属性，例如访问器属性中的set/get被用于VUE中的数据响应1234567891011121314151617//响应式数据绑定function defineReactive(obj, key, val) &#123; var dep = new Dep();//每个属性都有一个dep实例来对应多个watcher Object.defineProperty(obj, key, &#123; get: function () &#123; //添加watcher到dep中 if (Dep.target) dep.addSub(Dep.target) return val &#125;, set: function (n) &#123; if (n === val) return val = n; // 作为发布者发出通知 dep.notify(); &#125; &#125;)&#125; 6.2 创建对象6.2.1 工厂模式工厂模式?本质上就是将创建对象的步骤写在一个方法中 123456789101112function createPerson(name,age,job)&#123; var o=new Object(); o.name=name; o.age=age; o.job=job; o.sayName=function()&#123; alert(this.name) &#125;; return o&#125;;var person1=createPerson(&quot;xxx&quot;,22,&quot;worker&quot;);var person2=createPerson(&quot;xxx2&quot;,52,&quot;worker&quot;) 缺点：无法将其标记为一种特定的类型(person1与person2都是Object的实例) 6.2.2 构造函数模式像Object、Array这样的原生构造函数可以用来创建特定类型的对象，所以也可以创建自定义的构造函数的来定义自定义对象的属性和方法12345678910function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function()&#123; alert(this.name) &#125;;&#125;;var person1=new Person(&quot;xxx&quot;,22,&quot;worker&quot;);var person2=new Person(&quot;xxx2&quot;,52,&quot;worker&quot;) Person本身就是一个普通的函数而已，但是默认构造函数都是以首字母大写开头。要实现创建Person类的新实例，必须使用new操作符。 使用new会经历以下4个过程 创建一个新对象将构造函数的作用域赋给新对象（this指向新对象） 执行构造函数的代码返回新对象 标识对象类型1.使用对象(Object构造函数的原型对象上)的constructor(构造函数)属性2.使用instanceof(常用) 123person1.constructor==Personperson1 instanceof Person person1 instanceof Object 1.将构造函数当作函数 构造函数与其他函数的唯一区别就是调用方式的不同 1234567891011//接上面的例子//构造var person1=new Person(&quot;xxx&quot;,22,&quot;worker&quot;);person1.sayName()//xxx //普通Person(&quot;xxx2&quot;,52,&quot;worker&quot;);window.sayName()或者sayName()//xxx2 //另一对象中 var o=new Object();Person.call(o,&quot;xxx3&quot;,32,&quot;worker&quot;);o.sayName()//xxx3 构造函数的优缺点1.优点：可以将自定义构造函数的实例标识为一种特定的类型2.缺点： 当在构造函数中定义方法的时候，每个实例都要重新生成一个方法（对象），因为在ECMAScript中函数也是对象的一种。 123456789101112function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=function()&#123; alert(this.name) &#125;; //等价于this.sayName=new Function(&quot;alert(this.name)&quot;)&#125;;var person1=new Person(&quot;xxx&quot;,22,&quot;worker&quot;);var person2=new Person(&quot;xxx2&quot;,52,&quot;worker&quot;)alert(person1.sayName==(person2.sayName)//false 3.解决方案12345678910111213141516/* 1.将sayName指向的函数直接在函数外声明， 就可以避免每次实例化都要生成一次方法对象， 但是，这样做会在全局增加函数，那样自定义构造函数就没有封装性可言。 2.将方法写在原型对象中 */function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.sayName=sayName //等价于this.sayName=new Function(&quot;alert(this.name)&quot;)&#125;;function sayName()&#123; alert(this.name)&#125; 6.2.3 （构造函数的）原型模式 函数的prototype(原型)属性该属性存在于每一个函数之中，属性指向一个对象。此对象的作用是包含可以由特定类型的所有实例共享的属性和方法。 用原型模式改写纯构造函数模式 123456789function Person()&#123;&#125; Person.prototype.name=&quot;Nicholas&quot;;Person.prototype.age=29;Person.prototype.job=&quot;Software Engineer&quot;;Person.prototype.sayName=function()&#123; alert(this.name)&#125;;var person1=new Person();var person2=new Person() 1.理解原型对象 注意：1.当创建一个新的实例，该实例内部将包含一个指针[[prototype]]，指向构造函数的prototype。这个属性没有标准的方法可以访问，但是在ff/safari/chrome中支持用_proto_表示 2.默认情况下所有的原型对象都有一个constructor(构造函数)属性 指向prototype属性所在函数的指针(对象的constructor属性其实就是原型对象上的constructor) 关于原型的几个方法：1.isPrototypeOf:确定原型与实例的关系Person.prototype.isPrototypeOf(person1)//true 2.Object.getPrototypeOf:返回实例的原型，即[[prototype]]Object.getPrototypeOf(person1) 3.detele操作符：删除实例中的属性，常用于实例属性与原型属性重名的情况delete person1.name 4.hasOwnProperty:检测一个属性是否存在实例中12接上面的例子person1.hasOwnProperty(&apos;name&apos;)//false 2.原型与in操作符1).in操作符：判断对象是否能够访问给定的属性，无论这个属性是来自实例还是原型&quot;name&quot; in person1//true 结合hasOwnProperty可以判断属性是否来自原型 123function hasPrototypeProperty(o,n)&#123; return !o.hasOwnProperty(n) &amp;&amp; (n in o)&#125; 2).for in:返回能够通过对象访问的、[[Enumerable]]为true的属性。注意：对于IE8及以上，被重复定义（用户自定义的已经存在的对象属性，默认[[Enumerable]]为true）的不可枚举的属性也可以返回 3).Object.keys():获取本对象所有的可枚举[[Enumerable]]属性(不包括继承)12345678var keys=Object.keys(Person.prototype)//[&quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;];var p1=new Person()p1.name=2;p1.job=0;Object.defineProperty(p1,&quot;year&quot;,&#123;enumerable:false,vale:2019&#125;);var k2=Object.keys(p1);//[&quot;name&quot;, &quot;job&quot;] 4).Object.getOwnPropertyNames():获取本对象所有的属性(不包括继承) 1Object.getOwnPropertyNames(p1)//[&quot;name&quot;, &quot;job&quot;,&quot;year&quot;] 3.更简单的原型语法123456789101112function Person()&#123;&#125; Person.prototype=&#123; name:&quot;Nicholas&quot;, job:&quot;Software Engineer&quot;, sayName:function()&#123; alert(this.name) &#125;&#125;;var person1=new Person();var person2=new Person();person1.constructor==Person//falseperson1 instanceof Person//true 即重写了原型对象，最终效果不变，但是prototype中的constructor属性就不存在了，而是会引用Object上的constructor,此时不再指向Person(这就导致实例的constructor也跟着改变)，而是指向{}的构造函数Object。这时就不能用constructor来判断对象类型，而是用instanceof 如果要使用constructor判断，可以手动在原型对象中新增constructor属性，但是这样会导致constructor的[[Enumerable]]属性默认设置为true 123456789101112131415161718function Person()&#123;&#125; Person.prototype=&#123; //constructor:Person,//Enumerable为true name:&quot;Nicholas&quot;, job:&quot;Software Engineer&quot;, sayName:function()&#123; alert(this.name) &#125;&#125;;try&#123;Object.defineProperty(Person.prototype,&quot;constructor&quot;,&#123; enumerable:false, value:Person&#125;)&#125;catch(e)&#123; Person.prototype.constructor=Person&#125; 4.原型的动态性1234567891011121314151617//不改写prototype的情况下var friend = new Person();Person.prototype.sayHi=function()&#123; alert(&quot;hi&quot;)&#125;;friend.sayHi() //hi //改写了prototype的情况下var friend = new Person();//friend在创建时就自动为实例添加了链接最初原型的[[Prototype]]指针 Person.prototype=&#123; constructor:Person, sayName:function()&#123; alert(this.name) &#125;&#125;;//这个时候将会切断与friend的联系friend.sayName() //error 5.原生对象的原型6.原型对象的问题 缺点：所有方法、属性都在原型中共享。对于引用类型来说，假如在一个实例中改变了，其他的实例也会改变 12345678910111213function Person()&#123;&#125; Person.prototype=&#123; name:&quot;Nicholas&quot;, job:&quot;Software Engineer&quot;, friend:[&apos;jun&apos;,&apos;sam&apos;], sayName:function()&#123; alert(this.name) &#125;&#125;;var person1=new Person();person1.friend.push(&apos;calor&apos;)var person2=new Person();console.log(person2.friend)//[&quot;jun&quot;, &quot;sam&quot;, &quot;calor&quot;] 缺点联想：1234567Vue.component(&apos;button-counter&apos;, &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;,&#125;) 6.2.4 组合使用构造函数模式和原型模式(默认使用)1234567891011121314function Person(name,job)&#123; this.name=name; this.job=job; this.friend=[&apos;jun&apos;,&apos;sam&apos;]&#125; Person.prototype=&#123; sayName:function()&#123; alert(this.name) &#125;&#125;;var person1=new Person();person1.friend.push(&apos;calor&apos;)var person2=new Person();console.log(person2.friend)//[&quot;jun&quot;, &quot;sam&quot;] 6.2.5 动态原型模式6.3继承 继承的实现是依靠原型链 原型链的原理1.实例通过构造函数生成，因此有了[[prototype]]内部属性可以访问到构造函数的原型，因此可以继承原型上的属性与方法。2.利用这个特性，我们可以重写一个构造函数的原型，使其等于另一个构造函数的实例，那么该原型就会有了[[prototype]]内部属性可以访问到另一个构造函数的原型，这样就形成原型链 12345678910111213141516171819function SuperType()&#123; this.property=true&#125;;SuperType.prototype.getSuperValue=function()&#123; return this.property&#125;;function SubType()&#123; this.subproperty=false&#125;;//继承SubType.prototype = new SuperType();//添加SubType.prototype.getSubValue=function()&#123; return this.subproperty&#125;;var instance = new SubType();alert(instance.getSuperValue())//trueconsole.log(instance.constructor)//SuperType//现在引用的是SuperType.prototype.constructor 2.确定原型和实例的关系 instanceof &amp;&amp; isPrototypeOf() 12SuperType.prototype.isPrototypeOf instance//trueSubType.prototype.isPrototypeOf(instance)//true 3.谨慎地定义方法4.原型链的问题同样是引用类型带来的问题 123456789101112131415function SuperType()&#123; this.color=[&quot;black&quot;,&quot;blue&quot;,&quot;red&quot;]&#125;;function SubType()&#123; &#125;;//继承SubType.prototype = new SuperType();var instance1 = new SubType();var instance2 = new SubType();instance1.color.push(&apos;pink&apos;);console.log(instance2.color)// [&quot;black&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;pink&quot;] 6.3.3 组合继承（最终版本）12345678910111213141516171819202122232425function SuperType(name)&#123; this.name=name this.color=[&quot;black&quot;,&quot;blue&quot;,&quot;red&quot;]&#125;;SuperType.prototype.sayName=function()&#123; return this.name&#125;;function SubType(name,age)&#123; SuperType.call(this,name); this.age=age&#125;;//继承SubType.prototype = new SuperType();SubType.prototype.constructor=SubType;SubType.prototype.sayAge=function()&#123; return this.age&#125;;var instance1 = new SubType(&quot;c1&quot;,20);instance1.color.push(&quot;pink&quot;);console.log(instance1.sayName());//c1console.log(instance1.sayAge());//20var instance2 = new SubType(&quot;c2&quot;,63);console.log(instance2.sayName());//c2console.log(instance2.sayAge());//63console.log(instance2.color)// [&quot;black&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;pink&quot;] 番外 检测数组:Array.prototype.isArray() 12345var obj=&#123; arr1:[]&#125;Array.isArray(obj.arr1);//trueArray.isArray(obj.arr2);//Array.isArray(undefined);false instanceof 和 isArray当检测Array实例时, Array.isArray 优于 instanceof,因为Array.isArray能检测iframes。 12345678910var iframe = document.createElement(&apos;iframe&apos;);document.body.appendChild(iframe);//获取iframe对象下的Array方法xArray = window.frames[window.frames.length-1].Array;var arr = new xArray(1,2,3); // [1,2,3]// Correctly checking for ArrayArray.isArray(arr); // true// Considered harmful, because doesn&apos;t work though iframesarr instanceof Array; // false","tags":[{"name":"JS高设笔记","slug":"JS高设笔记","permalink":"https://duliz.github.io/tags/JS高设笔记/"}]},{"title":"用markdown生成脑图","date":"2019-05-12T07:22:01.000Z","path":"2019/05/12/用markdown生成脑图/","text":"说明 生成脑图工具：百度kityminder kityminder分为kityminder-core和kityminder-editor。 kityminder-core是 KityMinder 的核心实现部分，包括： 脑图数据的可视化展示（Json 格式）简单的编辑功能（节点创建、编辑、删除） kityminder-core 又依赖于Kity,kity 是一个基于 SVG 的矢量图形库 实现过程1.将js文件放置于themes/BlueLake/source/js文件中kity.min.jskityminder.core.js 2.将css文件转化为styl文件放置于themes/BlueLake/source/css文件中kityminder.core.styl 3.新建mind.js(themes/BlueLake/source/js)初始化脑图1234567891011121314151617setTimeout(function() &#123; var mindmap=document.querySelector(&quot;.mindmap&quot;) if (mindmap)&#123; var minder = new kityminder.Minder(&#123; renderTo: &apos;.mindmap&apos; &#125;); var markdownText = mindmap.innerText.trim(); mindmap.querySelectorAll(&quot;p&quot;).forEach(function(element,index) &#123; element.style.display = &apos;none&apos;; &#125;); minder.importData(&apos;markdown&apos;, markdownText); minder.disable(); minder.execCommand(&apos;hand&apos;);&#125;&#125;,100) 4.全局引入,在themes\\BlueLake\\layout\\base.jade中引入js与css1234link(rel=&apos;stylesheet&apos;, type=&apos;text/css&apos;, href=url_for(theme.css) + &apos;/kityminder.core.css&apos; + &apos;?v=&apos; + theme.version) script(type=&apos;text/javascript&apos;, src=url_for(theme.js) + &apos;/kity.min.js&apos; + &apos;?v=&apos; + theme.version)script(type=&apos;text/javascript&apos;, src=url_for(theme.js) + &apos;/kityminder.core.js&apos; + &apos;?v=&apos; + theme.version)script(type=&apos;text/javascript&apos;, src=url_for(theme.js) + &apos;/mind.js&apos; + &apos;?v=&apos; + theme.version) 5.在需要使用的页面中使用123456789&#123;% pullquote mindmap %&#125;#主题##一级分支###二级分支##一级分支##一级分支###二级分支####三级分支&#123;% endpullquote %&#125; #主题 ##一级分支 ###二级分支 ##一级分支 ##一级分支 ###二级分支 ####三级分支 注意事项1.当前版本仅支持本页面生成一个脑图（mind.js中的mindmap）2.全局引入js、css且执行延迟函数，考虑将其作为一个自定义模板 参考资料Hexo 渲染思维导图Hexo中使用markdown来绘制脑图（mind map）","tags":[{"name":"脑图","slug":"脑图","permalink":"https://duliz.github.io/tags/脑图/"}]},{"title":"第一篇 hello Hexo && 使用Hexo与Github搭建个人博客","date":"2019-04-08T14:27:50.000Z","path":"2019/04/08/第一篇hexo-blog-使用hexo与github搭建个人博客/","text":"初识Hexo介绍Hexo与Github搭建个人博客 初识hexoHexo是一款基于Node.js的可用于搭建静态博客框架 Hexo与Github搭建个人博客搭建所需要的工具 Github的一个新建库 Node/git客户端/cmd vsCode(支持markdown语法的编辑器) Hexo/Hexo主题：BlueLake 新建一个Github库注意：库名一定要使用.github.io作为后缀 Git安装成功后的初始化1.将Git与GitHub帐号绑定桌面右键–&gt;Git Bash Here输入 git config --global user.name &quot;&quot; git config --global user.email &quot;&quot; 2.填写个人信息，生成ssh密钥ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;然后直接三个回车即可，默认不需要设置密码找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 直接打开GitHub_Settings_keys，新建一个新的SSH Keys title可以随意填写，Key填写刚刚复制的id_rsa.pub内容测试是否设置成功：ssh git@github.com 在vsCode中使用Git Bash终端在vsCode(v1.33+)也可以直接开启Git Bash。方法：先找到Git Bash安装文件地址在vsCode中：设置–&gt;用户设置–&gt;终端–&gt;setting.json保存之后快捷键Ctrl + `打开终端控制台即可切换Bash 安装Hexo1.新建文件夹(myBlog)用来存放整个“网站”2.进入myBlog，在Node/Git Bash中都可以安装npm install -g hexo-cli安装成功后查看版本hexo -v3.在myBlog中新建main文件夹用于初始化一个网站hexo init main注意：init后面也可以不加文件夹，则默认在当前文件夹下创建，当要注意文件必须为空cd main进入mainnpm install成功安装完的文件结构如下 _config.ymlpackage.jsonscaffoldsthemessource _drafts_posts 部署到github1.安装hexo-deployer-gitnpm install hexo-deployer-git --save2.修改站点_config.yml配置3.生成静态文件，部署到Github中hexo g -d或 12hexo ghexo d 安装自定义主题1.在main文件夹下安装 123git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake npm install hexo-renderer-jade@0.3.0 --save npm install hexo-renderer-stylus --save 2.修改站点_config.yml配置文件，修改主题为BlueLaketheme: BlueLake 为主题新添iconfont在BlueLake主题中已经存在默认的iconfont 这些图片的命名规则由”fa-“ + 主题配置项_config.yml的中以下label决定 具体代码实现是位于themes/BlueLake/layout/page.jade 添加步骤：在不改变内部实现代码的前提下1.下载新的iconfont2.解压之后将svg、ttf、woff、woff2、eot文件改名并复制到themes/BlueLake/layout/source/iconfont文件夹下 3.在themes/BlueLake/layout/source/css/style.styl中新增一条@font-face规则 然后再添加 12.fa-QQ:before content: &quot;\\e64c&quot; 新建一篇博客hexo n &quot;博客名字&quot;生成后的博客位于themes/BlueLake/layout/source/_posts/生成的文件后缀名为md，该文件使用markdown编写(markdown语法记录在Markdown与图床) 新建一篇草稿草稿:位于themes/BlueLake/layout/source/drafts,drafts中的页面不会发布在线上hexo new draft 文章名 预览草稿hexo S --draft 将草稿发布为正式文章123hexo P 文章名 hexo g hexo d 原理:将文章从 source/_drafts 移动到 source/_posts 新建关于我页面hexo new page &#39;about&#39;BlueLake会自动与about按钮关联 为BlueLake添加搜索功能npm install hexo-generator-json-content@2.2.0 --save然后在站点_config.yml配置添加 1234567891011121314151617181920# theme blueLake search## Docs: https://chaoo.oschina.io/2016/12/29/BlueLake%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE.htmljsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 本地预览123hexo cleanhexo ghexo s --debug 博客置顶在BlueLake中已经存在置顶的标签themes/BlueLake/layout/index.jade但是置顶功能需要自己实现1234567891011121314var posts = locals.posts;//将原来的posts注释后加上 posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排&#125;); 然后在需要置顶的博客的Front-matter中加入top123456---title: 个人简历date: 2019-04-12 00:08:33tags:top: 2--- 修改要重新启动服务 资料参考链接GitHub+Hexo 搭建个人网站详细教程hexo-theme-BlueLake最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析hexo中文文档Hexo文章置顶的方法Hexo 文章保存为草稿","tags":[]}]